<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql</title>
      <link href="/2021/07/27/mysql/"/>
      <url>/2021/07/27/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java">DDL  定义DML  操作DQL  查询DCL  控制    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">MySQL</span>是一个关系型数据库管理系统，由瑞典<span class="token class-name">MySQL</span> AB 公司开发，属于 <span class="token class-name">Oracle</span> 旗下产品。在 WEB 应用方面，<span class="token class-name">MySQL</span>是最好的 RDBMS <span class="token punctuation">(</span><span class="token class-name">Relational</span> <span class="token class-name">Database</span> <span class="token class-name">Management</span> <span class="token class-name">System</span>，关系数据库管理系统<span class="token punctuation">)</span> 应用软件之一。<span class="token class-name">MySQL</span>是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。<span class="token class-name">MySQL</span>所使用的 SQL 语言是用于访问数据库的最常用标准化语言。<span class="token class-name">MySQL</span> 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java">关系型数据库<span class="token operator">:</span>表和表，行和列之间非关系型数据库<span class="token operator">:</span>对象存储<span class="token punctuation">,</span>通过对象自身的属性来决定 redis，mongDB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>DBMS</strong></p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">数据库管理系统<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><pre class="line-numbers language-jvaa" data-language="jvaa"><code class="language-jvaa">bin目录 放在环境设置的path中<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h1><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mysql -utoot -pupdate mysql.user set authentication_string=password('')where user='root' and Host = 'localhost'  --修改用户密码flush privileges  --刷新权限---------------------show databases;   --查看所有数据库use 数据库名show tables;      --查看所有表desc 表名create database 数据库名exit;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h1><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">create database if not exists 数据库名drop database if exists 数据库名 --存在就删除use `数据库名` --关键字+`` 使用数据库show databases --查看所有数据库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据库的列类型"><a href="#数据库的列类型" class="headerlink" title="数据库的列类型"></a>数据库的列类型</h3><blockquote><p>数值</p></blockquote><ul><li>tinyint                                           1字节</li><li>smallint                                         2字节</li><li>mediumint                                    3字节</li><li><strong>int                   标准整数           4字节</strong></li><li>bigint                                          8个字节</li><li>float                浮点数                 4字节</li><li>double 浮点数                            8字节 （精度问题!）</li><li>decimal          字符串形式的浮点数 （金融计算的使用）</li></ul><blockquote><p>字符串</p></blockquote><ul><li>char          固定大小字符串 0-255</li><li>**varchar  可变字符串 0-65535 **  String</li><li>tinytext   微型文本   2^8-1</li><li>text          文本串        2^16-1      大文本</li></ul><blockquote><p>时间日期</p></blockquote><ul><li>date     YYYY-MM-DD      日期格式</li><li>time    HH:mm:ss            时间格式</li><li><strong>datetime</strong></li><li>timestamp   时间戳        1970.1.1-现在的毫秒数</li><li>year</li></ul><blockquote><p>null</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">一般不用<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="数据库的字段属性"><a href="#数据库的字段属性" class="headerlink" title="数据库的字段属性"></a>数据库的字段属性</h3><p>Unsigned:</p><ul><li>无符号的整数</li><li>声明了该列不能为负数</li></ul><p>zerofill:</p><ul><li>0填充的</li><li>不足的位数,使用0填充   int(3)   5—005</li></ul><p>自增:</p><p>非空:</p><ul><li>必须赋值</li><li>默认null</li></ul><p>默认:</p><h3 id="阿里规范必须字段"><a href="#阿里规范必须字段" class="headerlink" title="阿里规范必须字段"></a>阿里规范必须字段</h3><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201010175446118.png" alt="image-20201010175446118"></p><h3 id="原始创建命令"><a href="#原始创建命令" class="headerlink" title="原始创建命令"></a>原始创建命令</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span>AUTO INCREMENT <span class="token comment">--自增</span><span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token keyword">COMMENT</span> <span class="token string">''</span>     <span class="token comment">--注释</span><span class="token keyword">DEFAULT</span> <span class="token string">''</span>     <span class="token comment">--默认</span><span class="token keyword">DATETIME</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span><span class="token string">'列名ID'</span><span class="token punctuation">)</span>    <span class="token comment">--主键</span><span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">INNODB</span>           <span class="token comment">--引擎</span><span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8   <span class="token comment">--编码</span><span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span>   逆向语句<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改命令"><a href="#修改命令" class="headerlink" title="修改命令"></a>修改命令</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">RENAME</span> <span class="token keyword">AS</span> 新表名  <span class="token comment">--修改表名</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">ADD</span> 字段 属性    <span class="token comment">--添加表字段</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 MODIEY 字段 属性  <span class="token comment">--修改约束</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 CHANGE 旧字段 新字段 属性  <span class="token comment">--重命名</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">DROP</span> 字段        <span class="token comment">--删除</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> 表名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="数据库引擎区别"><a href="#数据库引擎区别" class="headerlink" title="数据库引擎区别"></a>数据库引擎区别</h1><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INNODB</span>  默认使用  安全高，事务处理，多表多用户操作MyISAM  <span class="token number">5.5</span>版本  节约空间速度快<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><table><thead><tr><th></th><th>MyISAM</th><th>INNODB</th></tr></thead><tbody><tr><td>事务支持</td><td>不支持</td><td>支持</td></tr><tr><td>数据行锁定</td><td>不支持   表锁</td><td>行锁</td></tr><tr><td>外键约束</td><td>不支持</td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td>不支持</td></tr><tr><td>表空间大小</td><td>较小</td><td>较大，约为2倍</td></tr></tbody></table><p>索引数据库文件都在data目录下</p><p>本质文件的存储</p><p>MyISAM引擎在物理文件上的区别</p><ul><li>  INNODB在数据库中只有一个*.frm文件,和上级目录下的ibdata1文件</li><li>MyISAM<ul><li>*.frm 表结构定义文件</li><li>*.MYD 数据文件 data</li><li>*.MYI  索引文件 index</li></ul></li></ul><p>Mysql默认latin1,不支持中文</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">character-set-server=utf8my.ini  配置  一般不用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="MYSQL数据管理"><a href="#MYSQL数据管理" class="headerlink" title="MYSQL数据管理"></a>MYSQL数据管理</h1><h3 id="外键-了解"><a href="#外键-了解" class="headerlink" title="外键 (了解)"></a>外键 (了解)</h3><blockquote><p>物理外键:数据库级别</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//方案1</span><span class="token comment">//定义外键KEY </span><span class="token comment">//给外键添加约束constraint 当前的key绑定到那个key   </span><span class="token comment">//引用REFERENCES  那个表的那个字段</span>KEY `外键` <span class="token punctuation">(</span>`字段`<span class="token punctuation">)</span>CONSTRAINT `外键` <span class="token class-name">FOREIGN</span> KEY <span class="token punctuation">(</span>`字段`<span class="token punctuation">)</span> REFERENCES `table`<span class="token punctuation">(</span>`想要绑定的字段`<span class="token punctuation">)</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">//方案2ALTER TABLE 表名ADD CONSTRAINT `外键名` FOREIGN KEY(`自己字段`)REFERENCES `table`(`想要绑定的字段`)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">数据库操作语言<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h6><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> 表名 <span class="token punctuation">(</span>字段名<span class="token punctuation">)</span><span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h6 id="update"><a href="#update" class="headerlink" title="update"></a>update</h6><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> 表名 <span class="token keyword">SET</span> 列<span class="token operator">=</span><span class="token keyword">value</span> <span class="token keyword">WHERE</span> 运算符<span class="token operator">&lt;&gt;</span> <span class="token operator">!=</span> <span class="token comment">--不等于</span><span class="token operator">BETWEEN</span> <span class="token operator">AND</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h6><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span><span class="token number">5.7</span>存在问题<span class="token operator">!</span>删除<span class="token keyword">innodb</span> 重启数据库，自增从<span class="token number">1</span>开始 存在内存中，断电即失myisam 存在文件中<span class="token number">8.0</span>修复了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="truncate-ddl语言"><a href="#truncate-ddl语言" class="headerlink" title="truncate ddl语言"></a>truncate ddl语言</h6><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">TRUNCATE</span> 表名  <span class="token comment">--清空表</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>truncate和delete区别</p></blockquote><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">相同:都能删除数据，不会删除表结构不同:truncate 将自增计数器归0，不影响事务     delete 不影响自增<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="DQL-查询语言"><a href="#DQL-查询语言" class="headerlink" title="DQL 查询语言"></a>DQL 查询语言</h3><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201010213505728.png" alt="image-20201010213505728"></p><h6 id="select"><a href="#select" class="headerlink" title="select"></a>select</h6><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span><span class="token keyword">SELECT</span> 字段 <span class="token keyword">AS</span> 别名 <span class="token keyword">FROM</span> 表名 <span class="token keyword">AS</span> 别名CONCAT<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token comment">--拼接</span><span class="token keyword">SELECT</span> VERSION<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">--查询版本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="distinct-去重"><a href="#distinct-去重" class="headerlink" title="distinct 去重"></a>distinct 去重</h6><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> 字段 <span class="token keyword">FROM</span> 表名 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="where条件语句"><a href="#where条件语句" class="headerlink" title="where条件语句"></a>where条件语句</h6><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201010213908184.png" alt="image-20201010213908184"></p><h6 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h6><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token operator">%</span> 代表 <span class="token number">0</span><span class="token operator">-</span>任意字符 _ 一个字符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201010214252975.png" alt="image-20201010214252975"></p><h6 id="联表查询join"><a href="#联表查询join" class="headerlink" title="联表查询join"></a>联表查询join</h6><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">join</span> 连接的表 <span class="token keyword">on</span> 条件   连接查询<span class="token keyword">where</span>  等值查询<span class="token keyword">inner</span> <span class="token keyword">join</span> <span class="token keyword">left</span> <span class="token keyword">join</span><span class="token keyword">right</span> <span class="token keyword">join</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">inner</span> <span class="token keyword">join</span>   并集可以使用<span class="token keyword">where</span>相同名字需要取别名<span class="token keyword">AS</span> 可省略<span class="token keyword">ON</span> 条件是在生成临时表时使用的条件，它不管 <span class="token keyword">ON</span> 中的条件是否为真，都会返回左边表中的记录；<span class="token keyword">WHERE</span> 条件是在临时表已经生成后，对临时表进行的过滤条件。因为此时已经没有 <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> 的含义（必须返回左侧表的记录）了，所以如果 <span class="token keyword">WHERE</span> 条件不为真的记录就会被过滤掉。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201010214920142.png" alt="image-20201010214920142"></p><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201010220413187.png" alt="image-20201010220413187"></p><p><strong>自连接</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1</span>张表拆为<span class="token number">2</span>张一样的表<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201010221150855.png" alt="image-20201010221150855"></p><h6 id="分页limit和排序order-by"><a href="#分页limit和排序order-by" class="headerlink" title="分页limit和排序order by"></a>分页limit和排序order by</h6><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ASC</span> 升<span class="token keyword">DESC</span> 降<span class="token keyword">limit</span> <span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>pagesize <span class="token punctuation">,</span>pagesize<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h6 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h6><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">where</span><span class="token punctuation">(</span>值计算出来<span class="token punctuation">)</span><span class="token keyword">where</span> <span class="token operator">in</span>也可以使用<span class="token keyword">join</span> 查询<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201010223708969.png" alt="image-20201010223708969"></p><h6 id="分组和过滤having"><a href="#分组和过滤having" class="headerlink" title="分组和过滤having"></a>分组和过滤having</h6><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">分组后，过滤分组必须满足的次要条件在<span class="token keyword">group</span> <span class="token keyword">by</span> 下面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201011172929254.png" alt="image-20201011172929254"></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h6 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h6><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> ABS<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">)</span>    <span class="token comment">--绝对值</span>CEILING<span class="token punctuation">(</span><span class="token number">9.4</span><span class="token punctuation">)</span> <span class="token comment">--向上取整</span>FLOOR<span class="token punctuation">(</span><span class="token number">9.4</span><span class="token punctuation">)</span>   <span class="token comment">--向下取整</span>RAND        <span class="token comment">--0-1随机数</span>SIGN        <span class="token comment">--判断一个数的符号</span><span class="token comment">--------字符串</span>CHAR_LENGTH<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>CONCAT<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span>   <span class="token comment">--拼接</span><span class="token keyword">INSERT</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span> <span class="token comment">--从某个位子替换</span>LOWER<span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token comment">--小写</span>UPPER<span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token comment">--大写</span>INSTR<span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token comment">--查看第一次字符出现索引</span><span class="token keyword">REPLACE</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment">--替换</span>SUBSTR<span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token comment">--返回指定的字符串</span>REVERSE           <span class="token comment">--反转</span><span class="token comment">---------时间</span><span class="token keyword">CURRENT_DATE</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">--当前日期</span>CURDATE<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment">--当前</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token comment">--当前</span>LOCALTIEM<span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment">--本地</span>SYSDATE<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment">--系统</span><span class="token keyword">YEAR</span><span class="token punctuation">(</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token comment">--当前年</span><span class="token comment">--------系统</span><span class="token keyword">USER</span><span class="token punctuation">(</span><span class="token punctuation">)</span>VERSION<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java">where 不能使用聚合having可以<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>COUNT()</td><td>计数</td></tr><tr><td>SUM</td><td></td></tr><tr><td>AVG</td><td>平均</td></tr><tr><td>MAX</td><td></td></tr><tr><td>MIN</td><td></td></tr><tr><td>…</td><td></td></tr></tbody></table><blockquote><p>count区别</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">有主键 count 列 最快<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201011171357675.png" alt="image-20201011171357675"></p><p>MD5</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">原子性一致性隔离性持久性脏读不可重复读    幻读      mysql 默认开启事务自动提交<span class="token keyword">set</span> autocommit<span class="token operator">=</span> <span class="token number">0</span>   <span class="token comment">--关闭</span><span class="token keyword">start</span> <span class="token keyword">transaction</span>   <span class="token comment">--标记一个事务开始</span><span class="token keyword">commit</span>  <span class="token comment">--提交</span><span class="token keyword">rollback</span>  <span class="token comment">--回滚</span><span class="token keyword">set</span> autocommit<span class="token operator">=</span><span class="token number">1</span>  <span class="token comment">--开启自动提交</span><span class="token keyword">savepoint</span>       <span class="token comment">--设置一个事务的保存点</span><span class="token keyword">rollback</span> <span class="token keyword">to</span> <span class="token keyword">savepoint</span> <span class="token comment">--回滚到保存点</span><span class="token keyword">release</span> <span class="token keyword">savepoint</span>  <span class="token comment">--删除保存点</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h6 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java">帮助mysql高效获取数据的数据结构<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>主键索引 PRIMARY KEY<ul><li>唯一标识，不可重复,只能有一个列作为主键</li></ul></li><li>唯一索引 UNIQUE KEY <ul><li>避免重复的列出现，唯一索引可以重复</li></ul></li><li>常规索引 KEY/INDEX<ul><li>默认打的，index。key关键字设置</li></ul></li><li>全文索引 FULLTEXT<ul><li>快速定位数据</li></ul></li></ul><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201011182929370.png" alt="image-20201011182929370" style="zoom:50%;"><h6 id="测试100万条插入数据"><a href="#测试100万条插入数据" class="headerlink" title="测试100万条插入数据"></a>测试100万条插入数据</h6><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">--delimiter 定界符</span><span class="token comment">--declare   声明</span><span class="token keyword">DELIMITER</span> $$  <span class="token comment">--写函数之前必须要写，标志</span><span class="token keyword">CREATE</span> <span class="token keyword">FUNCTION</span> mock_data<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">RETURNS</span> <span class="token keyword">INT</span><span class="token keyword">BEGIN</span><span class="token keyword">DECLARE</span> num <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">1000000</span><span class="token punctuation">;</span><span class="token keyword">DECLARE</span> i <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">WHILE</span> i<span class="token operator">&lt;</span>num <span class="token keyword">DO</span><span class="token comment">--插入语句</span><span class="token keyword">SET</span> i <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">END</span> <span class="token keyword">WHILE</span>    <span class="token keyword">RETURN</span> i<span class="token punctuation">;</span><span class="token keyword">END</span><span class="token punctuation">;</span><span class="token comment">--创建索引</span><span class="token comment">--id_表名_字段名</span><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> 索引名 <span class="token keyword">on</span> 表<span class="token punctuation">(</span>字段<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="索引原则"><a href="#索引原则" class="headerlink" title="索引原则"></a>索引原则</h6><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">不是越多越好变动数据不加小数据亮不加一般加载常用的数据上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h6 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h6><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">HASH</span> 类型的索引<span class="token keyword">Btree</span>:<span class="token keyword">innodb</span> 默认的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p><h3 id="权限管理和备份"><a href="#权限管理和备份" class="headerlink" title="权限管理和备份"></a>权限管理和备份</h3><h6 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h6><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">用户表:mysql<span class="token punctuation">.</span><span class="token keyword">user</span><span class="token comment">--创建用户</span><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> 用户名 IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'密码'</span><span class="token comment">--修改</span><span class="token keyword">SET</span> PASSWORD<span class="token operator">=</span>PASSWPRD<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token keyword">SET</span> PASSWORD <span class="token keyword">FOR</span> 用户名 <span class="token operator">=</span>PASSWPRD<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token comment">--重命名</span><span class="token keyword">RENAME</span> <span class="token keyword">USER</span> 原名 <span class="token keyword">TO</span> 新名<span class="token comment">--用户授权ALL PRIVILEGES 全部权限,库.表</span><span class="token comment">--除了给别人授权没有</span><span class="token keyword">GRANT</span> <span class="token keyword">ALL</span> <span class="token keyword">PRIVILEGES</span> <span class="token keyword">ON</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> 用户<span class="token comment">--查询权限</span><span class="token keyword">SHOW</span> GRANTS <span class="token keyword">FOR</span> 用户<span class="token keyword">SHOW</span> GRANTS <span class="token keyword">FOR</span> root<span class="token variable">@localhost</span><span class="token comment">--root用户的权限</span><span class="token keyword">GRANT</span> <span class="token keyword">ALL</span> <span class="token keyword">PRIVILEGES</span> <span class="token keyword">ON</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> <span class="token string">'root@localhost'</span> <span class="token keyword">WITH</span> <span class="token keyword">GRANT</span> <span class="token keyword">OPTION</span><span class="token comment">--撤销权限</span><span class="token keyword">REVOKE</span> <span class="token keyword">ALL</span> <span class="token keyword">PRIVILEGES</span> <span class="token keyword">ON</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> 用户名<span class="token comment">--删除用户</span><span class="token keyword">DROP</span> <span class="token keyword">USER</span> 用户名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h6><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">重要数据不丢失数据转移<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>直接拷贝物理文件 data</li><li>在可视化工具手动导出</li><li>命令行</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mysqldump -h 主机 -u 用户名 -p 密码 数据库 表1 表2 &gt; 物理磁盘地址: 文件名--导入sql 先进入数据库source 路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">第一范式:原子性 每一列不可以再分每张表描述一件事情       满足第一范式每一列数据与主键直接相关  满足第一第二规范性和性能的问题阿里:关联查询不得超过<span class="token number">3</span>张表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">加一层连接各种数据库驱动只关注jdbc 而不再关注各种数据库驱动    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1.</span>导jar add as library<span class="token number">2.</span>第二种方案 maven    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201011202008542.png" alt="image-20201011202008542"></p><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201011202053686.png" alt="image-20201011202053686"></p><blockquote><p>DriveManager</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">源码里加载驱动    <span class="token class-name">DriveManager</span><span class="token punctuation">.</span><span class="token function">regsterDriver</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span></span>Driver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  不推荐这种方式因为会注册<span class="token number">2</span>次    <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>URL</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">--</span>mysql <span class="token number">3306</span><span class="token comment">//jdbc:mysql://主机地址:端口/数据库名?</span><span class="token operator">--</span>oralce <span class="token number">1521</span><span class="token comment">//jdbc:oracle:thin:@localhost:1521:sid    </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>connection</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">数据库对象<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>statement执行sql对象 preparestatement执行sql对象</p></blockquote><blockquote><p>resultset 查询结果集</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">获取指定数据类型 resultset<span class="token punctuation">.</span><span class="token function">getint</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">nwe <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span>properties<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>inputsream<span class="token punctuation">)</span>  inputsream<span class="token operator">:</span>可以使用类加载器获取流    properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"文件列名"</span><span class="token punctuation">)</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201011204109629.png" alt="image-20201011204109629"></p><p> preparestatement</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">预编译sql<span class="token operator">+</span>防止sql注入<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201011205955512.png" alt="image-20201011205955512"></p><h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">实现啊接口<span class="token class-name">DataSource</span>接口和连接池pool<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h3 id="二叉排序树BST"><a href="#二叉排序树BST" class="headerlink" title="二叉排序树BST"></a>二叉排序树BST</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">二叉查找树数组未排序，查找慢。数组排序，二分查找快，插入慢链表是否有序，查找都满，添加比数组快，不需要整体移动    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201012222112542.png" alt="image-20201012222112542"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">node 节点leftright  指针判断node值大小余，递归指向left 或right    中序遍历；递归    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除</p><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201013221023731.png" alt="image-20201013221023731"></p><h3 id="二叉树与b树"><a href="#二叉树与b树" class="headerlink" title="二叉树与b树"></a>二叉树与b树</h3><blockquote><p>二叉树问题</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">加载内存，节点太多，节点海量，速度慢<span class="token number">2</span><span class="token operator">^</span>n<span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201011220317748.png" alt="image-20201011220317748"></p><h3 id="多叉树"><a href="#多叉树" class="headerlink" title="多叉树"></a>多叉树</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">2</span>叉数 只有左右<span class="token number">2</span>个字点多叉树 允许每个节点有更多的数据项和更多的子节点    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201011220544881.png" alt="image-20201011220544881"></p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><pre class="line-numbers language-jvaa" data-language="jvaa"><code class="language-jvaa">通过降低树额高度，减少i/o读写次数来提升效率<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201011220944366.png" alt="image-20201011220944366"></p><h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><pre class="line-numbers language-jvaa" data-language="jvaa"><code class="language-jvaa">最简单的b树结构叶子节点在同一层由2节点和3节点构成,2节点必须有2个节点或者没有子节点，3节点同理插入一个数必须满足上面3个规则，不满足先向上拆，上层满，拆本层3节点子树值准守2叉排序树<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201011221512445.png" alt="image-20201011221512445"></p><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201011222030358.png" alt="image-20201011222030358"></p><h3 id="B树B-树B-树"><a href="#B树B-树B-树" class="headerlink" title="B树B+树B*树"></a>B树B+树B*树</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">全部都是数据<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201011223009117.png" alt="image-20201011223009117"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">关键字都在叶子节点链表中<span class="token punctuation">(</span>稠密索引<span class="token punctuation">)</span>非叶子节点<span class="token punctuation">(</span>稀疏索引<span class="token punctuation">)</span>适合文件索引 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201011223357978.png" alt="image-20201011223357978"></p><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201011223726290.png" alt="image-20201011223726290"></p><h1 id="mysql调优"><a href="#mysql调优" class="headerlink" title="mysql调优"></a>mysql调优</h1><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token number">1</span>、表的结构设计<span class="token number">2</span>、查询语句<span class="token number">3</span>、配置设置。尽量避免这个多表联合查询确保表中列字段上有正确合适的索引。确保有正确的锁定策略，<span class="token keyword">InnoDB</span>的共享锁（乐观锁 <span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE</span> <span class="token keyword">MODE</span>）<span class="token punctuation">,</span>悲观锁（查询语句<span class="token operator">+</span><span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span>）用于缓存的内存区域大小设置正确。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sql语句调优"><a href="#sql语句调优" class="headerlink" title="sql语句调优"></a>sql语句调优</h3><h4 id="where子句的优化"><a href="#where子句的优化" class="headerlink" title="where子句的优化"></a><strong>where子句的优化</strong></h4><p>l 删除条件中的不必要的小括号</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> <span class="token punctuation">(</span>a <span class="token operator">and</span> b<span class="token punctuation">)</span> <span class="token operator">and</span> C <span class="token operator">OR</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">and</span>  b<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>c an d <span class="token punctuation">)</span><span class="token punctuation">)</span>改进版：<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> <span class="token punctuation">(</span>a <span class="token operator">and</span> b<span class="token punctuation">)</span> <span class="token operator">and</span> C <span class="token operator">OR</span> <span class="token punctuation">(</span>a <span class="token operator">and</span>  b <span class="token operator">and</span> c an d <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>l 恒定折叠原则</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token punctuation">(</span> a<span class="token operator">&lt;</span>b <span class="token operator">and</span> b<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">OR</span> <span class="token punctuation">(</span>b<span class="token operator">=</span><span class="token number">6</span> <span class="token operator">and</span> <span class="token number">5</span><span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span> 改进版：a<span class="token operator">&lt;</span><span class="token number">5</span> <span class="token operator">OR</span>  b<span class="token operator">=</span><span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>l 索引使用的常量表达式最多计算一次</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">age这个列是索引age<span class="token operator">&lt;</span><span class="token number">30</span><span class="token punctuation">,</span>  age<span class="token operator">+</span><span class="token number">5</span><span class="token operator">&lt;</span><span class="token number">35</span><span class="token punctuation">,</span>这种写法，就可能会造成索引失效，所以最好就是不要在索引列上做算术运算但实际上可以做一次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>l 如果使having字句的时候，如果没有 group by 或者没有聚合函数，这个时候，应该把having字句的条件合并到where</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> user_id <span class="token punctuation">,</span>name<span class="token punctuation">,</span>age <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> name<span class="token operator">=</span>’张<span class="token operator">%</span>’ <span class="token keyword">group</span> <span class="token keyword">by</span> age <span class="token keyword">having</span> age<span class="token operator">&gt;</span><span class="token number">30</span>如果此时没有<span class="token keyword">group</span> <span class="token keyword">by</span> 那么就应该把age<span class="token operator">&gt;</span><span class="token number">30</span>这个条件合并到<span class="token keyword">where</span>里边去就成了：<span class="token keyword">select</span> user_id <span class="token punctuation">,</span>name<span class="token punctuation">,</span>age <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> name<span class="token operator">=</span>’张<span class="token operator">%</span>’ <span class="token operator">and</span> age<span class="token operator">&gt;</span><span class="token number">30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>l 对于每个Join，构造更小的where条件结果集（也就是多加关联条件），使得where能够跳过一些行使得查询速度更快</p><p>l 在查询所有的其他表之前，先查常量表，因为常量表最快，也就可以跳过很多不必要的查询了</p><h4 id="范围优化"><a href="#范围优化" class="headerlink" title="范围优化"></a><strong>范围优化</strong></h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">age<span class="token operator">&gt;=</span><span class="token number">25</span><span class="token punctuation">,</span>这种就叫范围查询（range）。    <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1、如果要让索引不失效，那么就要满足一些条件：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">对于两种索引（从数据结构分）<span class="token keyword">BTREE</span>索引，<span class="token keyword">HASH</span>索引，使用的时候，条件部分，如果用到<span class="token operator">=</span>、 <span class="token operator">&lt;=&gt;</span><span class="token punctuation">(</span>安全等于号，比较<span class="token boolean">null</span><span class="token punctuation">)</span> 、<span class="token operator">IN</span><span class="token punctuation">(</span><span class="token punctuation">)</span>、<span class="token operator">is</span> <span class="token boolean">NULL</span> 、<span class="token operator">is</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">,</span>这些范围的时候，都会生效索引<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2、对于BTREE索引，当使用where条件的时候，可以使用 &gt;,&gt;=,&lt;,&lt;=,BETWEEN,!=,&lt;&gt;这些的时候，索引不会失效</p><p><strong>还有 like 一定要不能以%开头！！！</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> nick_name <span class="token operator">like</span> ‘<span class="token operator">%</span>大’  <span class="token operator">-</span><span class="token operator">&gt;</span>索引失效<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> nick_name <span class="token operator">like</span> ‘大<span class="token operator">%</span>’  <span class="token operator">-</span><span class="token operator">&gt;</span>索引生效<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>业务需求：根据手机尾号查询用户！如何写sql?</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">select <span class="token operator">*</span> from user where  phone like  <span class="token function">CONCAT</span><span class="token punctuation">(</span>‘<span class="token operator">%</span>’<span class="token punctuation">,</span>#<span class="token punctuation">{</span>phone<span class="token punctuation">}</span><span class="token punctuation">)</span>虽然实现了尾号查询，但是导致我们的phone这列的索引失效！所以解决方案：外国螺丝反着转，很简单，把手机号，反起来存！<span class="token number">18223170162</span>在业务层里边，我把这个手机号，反转，<span class="token class-name">String</span>类里边有个反转字符串reverse方法，那么反转之后，就变成 <span class="token number">2610</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>当要查询<span class="token number">0162</span>尾号结尾的手机的时候，我们把参数反转，传过来的参数是<span class="token number">0162</span>，反转之后就是 <span class="token number">2610</span>sql语句怎么写？select <span class="token operator">*</span> from user where  phone like  <span class="token function">CONCAT</span><span class="token punctuation">(</span>#<span class="token punctuation">{</span>phone<span class="token punctuation">}</span><span class="token punctuation">,</span>‘<span class="token operator">%</span>’<span class="token punctuation">,</span><span class="token punctuation">)</span>，这个时候索引就会生效了，因为是不是以’<span class="token operator">%</span>’开头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、对于HASH索引，不好意思，只有 or  and  形成一个范围组合。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">检索效率非常高，索引的检索可以一次定位，不像<span class="token class-name">B</span><span class="token operator">-</span><span class="token class-name">Tree</span> 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 <span class="token class-name">Hash</span> 索引的查询效率要远高于 <span class="token class-name">B</span><span class="token operator">-</span><span class="token class-name">Tree</span> 索引。    <span class="token class-name">Hash</span> 索引仅仅能满足<span class="token string">"="</span><span class="token punctuation">,</span><span class="token string">"IN"</span>和<span class="token string">"&lt;=&gt;"</span>查询，不能使用范围查询。由于 <span class="token class-name">Hash</span> 索引比较的是进行 <span class="token class-name">Hash</span> 运算之后的 <span class="token class-name">Hash</span> 值，所以它只能用于等值的过滤<span class="token class-name">Hash</span> 索引在任何时候都不能避免表扫描。<span class="token class-name">Hash</span> 索引遇到大量<span class="token class-name">Hash</span>值相等的情况后性能并不一定就会比<span class="token class-name">B</span><span class="token operator">-</span><span class="token class-name">Tree</span>索引高。    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="is-null-优化"><a href="#is-null-优化" class="headerlink" title="is null 优化"></a><strong>is null 优化</strong></h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">举个例子：select <span class="token operator">*</span> from user where real_name<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span>这样会导致索引失效的，也就是说，所以列上边不要用<span class="token keyword">null</span>改进版 select <span class="token operator">*</span> from user where real_name is <span class="token keyword">null</span>。那么在实际开发之中，你就不要给我写这种sqlselect <span class="token operator">*</span> from user where real_name<span class="token operator">=</span>#<span class="token punctuation">{</span>realName<span class="token punctuation">}</span>在执行这个语句之前，请务必判断realName不是<span class="token keyword">null</span><span class="token punctuation">,</span>否则查询可能会导致很慢    也可以用mybatis 的动态sql判断    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">select <span class="token operator">*</span> from user order by key1<span class="token punctuation">,</span>key2 这个时候<span class="token operator">*</span>会查询的列会多余key1和key2，在这种情况下， 扫描整个索引树，会比较消耗时间，所以mysql很可能不会去用索引，因为<span class="token operator">*</span> 表示的是什么，mysql不知道，他要先去查字段，然后再看字段是不是有所以，这样就会非常消耗时间，所以就可能不会用到索引，于是，我们就不应该用<span class="token operator">*</span>怎么去改进：select key1<span class="token punctuation">,</span>key2 from user order by key1<span class="token punctuation">,</span>key2直接显示的把要查询的列写出来！     不要用<span class="token operator">*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="分组优化"><a href="#分组优化" class="headerlink" title="分组优化"></a><strong>分组优化</strong></h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">要满足一些条件必须是单表查询查询的列如果是<span class="token punctuation">(</span>c1<span class="token punctuation">,</span>c2<span class="token punctuation">,</span>c3<span class="token punctuation">)</span>那么分组顺序就必须是 c1<span class="token punctuation">,</span>c2这么写，你不能够 写成 c2<span class="token punctuation">,</span>c1<span class="token punctuation">,</span>也不能够写成c1<span class="token punctuation">,</span>c3group by c1<span class="token punctuation">,</span>c2<span class="token punctuation">,</span>c3<span class="token punctuation">,</span>严格按照查询的列的顺序来写，不要随便捣乱顺序！列表中的如果有使用聚合函数如果是<span class="token function">MIN</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span>或者<span class="token function">MAX</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span> ，他们必须全部用引用同一列。money 字段，你不能够一会儿去求<span class="token function">min</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span>一会又去求最小的金钱<span class="token function">MAX</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span class="token punctuation">,</span>要么就写成<span class="token function">MAX</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">,</span>最好不要在sql语句中去搞这些函数，那么我们怎么去统计呢？JAVA8特性 <span class="token class-name">Stream</span> API可以帮我们非常简单高效的实现。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a><strong>limit优化</strong></h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">select <span class="token operator">*</span> from user where  a<span class="token operator">=</span>b  limit #<span class="token punctuation">{</span>start<span class="token punctuation">}</span><span class="token punctuation">,</span>#<span class="token punctuation">{</span>limit<span class="token punctuation">}</span>覆盖索引的方式优化，可以少部分提升查询性能，大概<span class="token number">20</span><span class="token operator">%</span>左右或者使用mysql8    使用游标分页查询根据用户上一次查询的最后一个主键id记录下来上一次用户查询到了哪里，这个时候我们就可以根据用户查询的位置，来确定用户的查询的偏移量。SELECT <span class="token operator">*</span> from `user` WHERE user_id<span class="token operator">&gt;</span><span class="token number">4900042</span> LIMIT <span class="token number">20</span> 这个游标是可以从前端传递过来的，因为前端每次查询之后，都有主键id，那么我们就直到上次查询的时候，最后的主键id是多少，就根本没有必要再去 page<span class="token operator">*</span>pageSize<span class="token operator">=</span>start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201013222504992.png" alt="image-20201013222504992"></p><h4 id="禁止全表（大表）扫描"><a href="#禁止全表（大表）扫描" class="headerlink" title="禁止全表（大表）扫描"></a><strong>禁止全表（大表）扫描</strong></h4><h4 id="explain关键字！"><a href="#explain关键字！" class="headerlink" title="explain关键字！"></a>explain关键字！</h4><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201013222812329.png" alt="image-20201013222812329"></p><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201013222817260.png" alt="image-20201013222817260"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1</span>、id<span class="token operator">:</span>指的sql语句的执行id<span class="token punctuation">,</span>不是我们的表中的id<span class="token punctuation">,</span>这个id是执行计划用来描述那个sql语句的执行顺序的，id越高越先执行<span class="token number">2</span>、select_type查询方式，常用的一些<span class="token operator">:</span>SIMPLE<span class="token operator">:</span>简单的查询，不嵌套子查询，也没有UNION连接查询PRIMARTY：主要的查询，就最外层的SQL语句UNION：表示UNION联合中的第二个或者后面的查询语句SUBQUERY：子查询的第一个SELECTDERIVED：到处表的SELECT的子查询DEPENDENT SUBQUERY：子查询中的第一个SELECT，取决与外面包含的查询语句<span class="token number">3</span>、table 指的表名<span class="token number">4</span>、type类型：描述的是查询性能<span class="token class-name">System</span><span class="token operator">&gt;</span><span class="token keyword">const</span><span class="token operator">&gt;</span>eq_ref<span class="token operator">&gt;</span>ref<span class="token operator">&gt;</span>unique_subquery<span class="token operator">&gt;</span>index_subquery<span class="token operator">&gt;</span>range<span class="token operator">&gt;</span>index<span class="token operator">&gt;</span>ALL<span class="token class-name">System</span>只是一个<span class="token keyword">const</span>的特例，表中只有一行记录的时候，就是<span class="token class-name">System</span>级别的。<span class="token keyword">const</span><span class="token operator">:</span>根据主键查询等值的时候，会出现，基本很难eq_ref：多表的时候，关联的是主键查询，就是这个级别ref<span class="token operator">:</span>表示用到了索引unique_subquery：子查询用到了唯一索引index_subquery：子查询用到了索引树扫描range：用到了范围查询（工作之中到达这个级别，就赞！！）index<span class="token operator">:</span>扫描索引树级别，就勉强，看具体业务需求，一般都需要优化ALL：表示很垃圾，全表扫描，几乎都要优化，除非表很小！<span class="token number">5</span>、possible_keys：可能用到的索引；<span class="token number">6</span>、key<span class="token operator">:</span>实际用到的索引<span class="token number">7</span>、rows：要扫描的行数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20201013222856549.png" alt="image-20201013222856549"></p><h3 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a><strong>索引</strong></h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">从数据结构分，两种：BTREE和HASHBTREE、HASH的特点就是符合<span class="token operator">=</span> 、<span class="token operator">&lt;=</span><span class="token operator">&gt;</span>、 is <span class="token keyword">null</span> is not <span class="token keyword">null</span> <span class="token function">IN</span><span class="token punctuation">(</span><span class="token punctuation">)</span>、这些操作符。HASH索引就只能用于等值查询HASH，就是一个KEY对应一个值，一个指针，指向了一个区域。    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="优化数据库结构"><a href="#优化数据库结构" class="headerlink" title="优化数据库结构"></a><strong>优化数据库结构</strong></h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1</span>、能小就小！比方说设计一个年龄的字段，整型，但是整型有很多，年龄就应该设计成tinyint<span class="token punctuation">,</span>最小的<span class="token punctuation">,</span>这样不仅仅节省磁盘空间，而且还能提升查询效率。男女也应该用最小的类型<span class="token number">2</span>、不是<span class="token keyword">null</span>的列，尽可能的标记成不是<span class="token keyword">null</span>  <span class="token number">3</span>、<span class="token keyword">char</span>类型和varchar的使用，如果定长，那么就用CHAR，因为查询更快，但是空间要占用多一点，典型的就是空间换时间，比如手机号，<span class="token number">11</span>位，就应该设计成<span class="token function">CHAR</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token number">4</span>、列名称尽量短，比如 user_name可以直接叫name<span class="token punctuation">,</span>不要写 zhonghua_renmin_gonghe_guo<span class="token punctuation">,</span>这就字段太长了，一般就<span class="token number">1</span><span class="token operator">-</span><span class="token number">2</span>个单词下划线组合就可以，这个也是可以提高查询效率的。<span class="token number">5</span>、把多列表拆分成多个小表，比如用户登陆表和用户信息表<span class="token number">6</span>、尽量不要用冗余字段，尽量都用外键关联，但是外键呢，我建议用逻辑外键。<span class="token number">7</span>、内容尽量用数字类型的，能用数字的，就不要用字符串。ONSAL，TRUE，<span class="token number">1</span>，<span class="token number">0</span>，所以为什么你会看到有些查询出来是返回的数字。SUCCESS    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 关系数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8</title>
      <link href="/2021/07/05/java8/"/>
      <url>/2021/07/05/java8/</url>
      
        <content type="html"><![CDATA[<h1 id="java-8-in-action"><a href="#java-8-in-action" class="headerlink" title="java 8 in action"></a>java 8 in action</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java">函数式比命令式更适应新的体系架构<span class="token class-name">Java</span> <span class="token number">8</span>的核心新特性：<span class="token class-name">Lambda</span>（匿名函数）、流、默认方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h4 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h4><pre class="line-numbers language-none"><code class="language-none">流是一系列数据项，一次只生成一项。程序可以从输入流中一个一个读取数据项，然后以同样的方式将数据项写入输出流。一个程序的输出流很可能是另一个程序的输入流。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="API传递代码"><a href="#API传递代码" class="headerlink" title="API传递代码"></a>API传递代码</h4><pre class="line-numbers language-none"><code class="language-none">Java 8增加了把方法（你的代码）作为参数传递给另一个方法的能力。我们把这一概念称为行为参数化。它的重要之处在哪儿呢？Stream API就是构建在通过传递代码使操作行为实现参数化的思想上的<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="并行与共享的可变数据"><a href="#并行与共享的可变数据" class="headerlink" title="并行与共享的可变数据"></a>并行与共享的可变数据</h4><pre class="line-numbers language-none"><code class="language-none">没有共享的可变数据，将方法和函数即代码传递给其他方法的能力）是我们平常所说的函数式编程范式的基石。但如果要写入的是一个共享变量或对象，这就行不通了：如果两个进程需要同时修改这个共享变量怎么办你的行为必须能够同时对不同的输入安全地执行。一般情况下这就意味着，你写代码时不能访问共享的可变数据。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="新功能简介"><a href="#新功能简介" class="headerlink" title="新功能简介"></a>新功能简介</h1><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用::"></a>方法引用::</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">用<span class="token class-name">Java</span> <span class="token number">8</span>的方法引用<span class="token operator">::</span>语法（即“把这个方法作为值”）将其传给listFiles方法需求<span class="token operator">:</span>你想要筛选一个目录中的所有隐藏文件    <span class="token comment">//原始  需要包在new FileFilter()里在传递给File.listFiles  </span><span class="token class-name">File</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hiddenFiles <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token class-name">File</span> file<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> file<span class="token punctuation">.</span><span class="token function">isHidden</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//java 8</span><span class="token class-name">File</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hiddenFiles <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token class-name">File</span><span class="token operator">::</span><span class="token function">isHidden</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h6 id="传递代码例子"><a href="#传递代码例子" class="headerlink" title="传递代码例子"></a>传递代码例子</h6></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isGreenApple</span><span class="token punctuation">(</span><span class="token class-name">Apple</span> apple<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token string">"green"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>apple<span class="token punctuation">.</span><span class="token function">getColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isHeavyApple</span><span class="token punctuation">(</span><span class="token class-name">Apple</span> apple<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> apple<span class="token punctuation">.</span><span class="token function">getWeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">150</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//----------------------------</span><span class="token comment">//方法作为 Predicate参数p传递进去</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Predicate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>  <span class="token keyword">boolean</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">//--------------------------------------------------------------------------</span><span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Apple</span><span class="token punctuation">&gt;</span></span> <span class="token function">filterApples</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Apple</span><span class="token punctuation">&gt;</span></span> inventory<span class="token punctuation">,</span> <span class="token class-name">Predicate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Apple</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Apple</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Apple</span> apple<span class="token operator">:</span> inventory<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>apple<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment">//-------------------------使用--------------</span><span class="token function">filterApples</span><span class="token punctuation">(</span>inventory<span class="token punctuation">,</span> <span class="token class-name">Apple</span><span class="token operator">::</span><span class="token function">isGreenApple</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">filterApples</span><span class="token punctuation">(</span>inventory<span class="token punctuation">,</span> <span class="token class-name">Apple</span><span class="token operator">::</span><span class="token function">isHeavyApple</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：后者则希望接受一个Predicate<apple>参数。<strong>谓词</strong>（predicate）在数学上常常用来代表一个类似函数的东西，它接受一个参数值，并返回true或false。</apple></p><blockquote><h6 id="从传递方法到-Lambda"><a href="#从传递方法到-Lambda" class="headerlink" title="从传递方法到 Lambda"></a>从传递方法到 Lambda</h6></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">filterApples</span><span class="token punctuation">(</span>inventory<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">Apple</span> a<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> a<span class="token punctuation">.</span><span class="token function">getWeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">150</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>直接调用库方法filter<span class="token function">filter</span><span class="token punctuation">(</span>inventory<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">Apple</span> a<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> a<span class="token punctuation">.</span><span class="token function">getWeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">150</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h6 id="流"><a href="#流" class="headerlink" title="流"></a>流</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Currency</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Transaction</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> transactionsByCurrencies <span class="token operator">=</span>  transactions<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Transaction</span> t<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> t<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1000</span><span class="token punctuation">)</span>   <span class="token operator">&lt;</span><span class="token operator">--</span><span class="token operator">-</span>筛选金额较高的交易 <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">Transaction</span><span class="token operator">::</span><span class="token function">getCurrency</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">--</span><span class="token operator">-</span>按货币分组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h6 id="多线程并行"><a href="#多线程并行" class="headerlink" title="多线程并行"></a>多线程并行</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java">顺序处理：<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Apple</span><span class="token punctuation">&gt;</span></span> heavyApples <span class="token operator">=</span>  inventory<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Apple</span> a<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> a<span class="token punctuation">.</span><span class="token function">getWeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">150</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>并行处理：<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Apple</span><span class="token punctuation">&gt;</span></span> heavyApples <span class="token operator">=</span>  inventory<span class="token punctuation">.</span><span class="token function">parallelStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Apple</span> a<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> a<span class="token punctuation">.</span><span class="token function">getWeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">150</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：<strong>函数式编程</strong>中 的<strong>函数</strong>的主要意思是“把函数作为一等值”，不过它也常常隐含着第二层意思，即“执行时在</p><p>元素之间无互动”。</p><h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//解决:给接口加入一个新方法，意味着所有的实体类都必须为其提供一个实现</span><span class="token class-name">Java</span> <span class="token number">8</span>中加入默认方法主要是为了支持库设计师，让他们能够写出更容易改进的接口。<span class="token class-name">Java</span> <span class="token number">8</span>在接口声明中使用新的<span class="token keyword">default</span>关键字来表示这一点。例如，在<span class="token class-name">Java</span> <span class="token number">8</span>里，你现在可以直接对<span class="token class-name">List</span>调用sort方法。它是用<span class="token class-name">Java</span> <span class="token number">8</span> <span class="token class-name">List</span>接口中如下所示的默认方法实现的，它会调用<span class="token class-name">Collections</span><span class="token punctuation">.</span>sort静态方法：    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="其他思想"><a href="#其他思想" class="headerlink" title="其他思想"></a>其他思想</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>类，如果你能一致地使用它的话，就可以帮助你避免出现<span class="token class-name">NullPointer</span>异常。它是一个容器对象，可以包含，也可以不包含一个值。（结构）模式匹配<span class="token operator">:</span><span class="token keyword">switch</span>的扩展形式，可以同时将一个数据类型分解成元素。    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">语言面临的“要么改变，要么衰亡”<span class="token class-name">Java</span> <span class="token number">8</span>中新增的核心内容提供了令人激动的新概念和功能现有的<span class="token class-name">Java</span>编程实践并不能很好地利用多核处理器。函数作为一等值；方法如何作为函数式值来传递，还有<span class="token class-name">Lambda</span>是怎样写的   <span class="token class-name">Streams</span>的概念使得<span class="token class-name">Collections</span>的许多方面得以推广，让代码更为易读，并允许并行处理流元素    在接口中使用默认方法，在实现类没有实现方法时提供方法内容   处理<span class="token keyword">null</span>和使用模式匹配    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="行为参数化传递代码"><a href="#行为参数化传递代码" class="headerlink" title="行为参数化传递代码"></a>行为参数化传递代码</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java">行为参数化就是可以帮助你处理频繁变更的需求的一种软件开发模式。定义一个抽象接口，具体代码实现抽象接口。将抽象接口作为参数：方法的行为取决于你传递的具体代码实现，导致整个方法行为参数化了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis6</title>
      <link href="/2021/06/30/redis6/"/>
      <url>/2021/06/30/redis6/</url>
      
        <content type="html"><![CDATA[<h1 id="2-redis概述安装"><a href="#2-redis概述安装" class="headerlink" title="2. redis概述安装"></a>2. redis概述安装</h1><h4 id="2-1-redis概述"><a href="#2-1-redis概述" class="headerlink" title="2.1 redis概述"></a>2.1 redis概述</h4><pre class="line-numbers language-none"><code class="language-none">1:开源的key-value 存储系统2:string, list, set, zset(有序集合), hash3:只存储 push/pop add/remove 及取交集并集复杂操作,原子性4:支持不同方式排序5:效率,缓存在内存中6:redis周期性更新数据到磁盘 (持久化)7：实现了 master-slave<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-redis用途"><a href="#2-2-redis用途" class="headerlink" title="2.2 redis用途"></a>2.2 redis用途</h4><pre class="line-numbers language-none"><code class="language-none">配合关系型数据库做高速缓存--高频次，热门访问的数据，降低数据库IO--分布式架构，做session共享多样的数据结构存储持久化数据--最新N个数据 List实现自然排序数据--排行榜  zset--手机验证码 Expire过期--计数器,秒杀  原子性,自增方法INCR、DECR--去大量数据重复    set--构建队列  list--发表订阅消息 pub/sub模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-Linux安装"><a href="#2-3-Linux安装" class="headerlink" title="2.3 Linux安装"></a>2.3 Linux安装</h4><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲redis-check-dump：修复有问题的dump.rdb文件redis-sentinel：Redis集群使用redis-server：Redis服务器启动命令redis-cli：客户端，操作入口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">#因为容器内没有redis.conf 所以需要现在外面创建在挂载mkdir -p /mydata/redis/conftouch /mydata/redis/conf/redis.confdocker run -p 6379:6379 --name redis \-v /mydata/redis/data:/data \-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \-d redis redis-server /etc/redis/redis.confdocker exec -it redis redis-cli  #运行redis容器客服端#默认存在内存，没有持久化 修改redis.confpwdvi redis.confappendonly yes#虚拟机重启自动启动docker update mysql --restart=always<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4-reids-相关技术"><a href="#2-4-reids-相关技术" class="headerlink" title="2.4 reids 相关技术"></a>2.4 reids 相关技术</h4><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">默认16个数据库 默认从 0开始#select 15  切换数据库 flushdb flushall 清空Redis是单线程+多路IO复用技术多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）串行   vs   多线程+锁（memcached） vs   单线程+多路IO复用(Redis)（与Memcache三点不同: 支持多数据类型，支持持久化，单线程+多路IO复用） <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-redis数据类型"><a href="#3-redis数据类型" class="headerlink" title="3. redis数据类型"></a>3. redis数据类型</h1><h4 id="3-1-reids键-key"><a href="#3-1-reids键-key" class="headerlink" title="3.1 reids键(key)"></a>3.1 reids键(key)</h4><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">#set k1 v1keys *查看当前库所有key    (匹配：keys *1)exists key判断某个key是否存在type key 查看你的key是什么类型del key       删除指定的key数据unlink key   根据value选择非阻塞删除,仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。expire key 10   10秒钟：为给定的key设置过期时间ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期select命令切换数据库dbsize查看当前数据库的key的数量flushdb清空当前库flushall通杀全部库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-字符串-String"><a href="#3-2-字符串-String" class="headerlink" title="3.2 字符串(String)"></a>3.2 字符串(String)</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#底层数据结构String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。#底层数据结构String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512Mset   &lt;key&gt;&lt;value&gt;添加键值对setNX：当数据库中key不存在时，可以将key-value添加数据库setXX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥setEX：key的超时秒数setPX：key的超时毫秒数，与EX互斥get   &lt;key&gt;查询对应键值append  &lt;key&gt;&lt;value&gt;将给定的&lt;value&gt; 追加到原值的末尾strlen  &lt;key&gt;获得值的长度setnx  &lt;key&gt;&lt;value&gt;只有在 key 不存在时    设置 key 的值#原子性操作incr  &lt;key&gt;将 key 中储存的数字值增1只能对数字值操作，如果为空，新增值为1decr  &lt;key&gt;将 key 中储存的数字值减1只能对数字值操作，如果为空，新增值为-1incrby / decrby  &lt;key&gt;&lt;步长&gt;将 key 中储存的数字值增减。自定义步长。#原子性操作#多值操作mset  &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;  ..... 同时设置一个或多个 key-value对  mget  &lt;key1&gt;&lt;key2&gt;&lt;key3&gt; .....同时获取一个或多个 value  msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;  ..... 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。原子性，有一个失败则都失败#多值操作getrange  &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;获得值的范围，类似java中的substring，前包，后包setrange  &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;用 &lt;value&gt;  覆写&lt;key&gt;所储存的字符串值，从&lt;起始位置&gt;开始(索引从0开始)。setex  &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;设置键值的同时，设置过期时间，单位秒。getset &lt;key&gt;&lt;value&gt;以新换旧，设置了新值同时获得旧值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-redis列表-List"><a href="#3-3-redis列表-List" class="headerlink" title="3.3 redis列表(List)"></a>3.3 redis列表(List)</h4><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">#底层数据结构List的数据结构为快速链表quickList。首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。#底层数据结构lpush/rpush  &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; .... 从左边/右边插入一个或多个值。lpop/rpop  &lt;key&gt;从左边/右边吐出一个值。值在键在，值光键亡。rpoplpush  &lt;key1&gt;&lt;key2&gt;从&lt;key1&gt;列表右边吐出一个值，插到&lt;key2&gt;列表左边。lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;按照索引下标获得元素(从左到右)lrange mylist 0 -1   0左边第一个，-1右边第一个，（0-1表示获取所有）lindex &lt;key&gt;&lt;index&gt;按照索引下标获得元素(从左到右)llen &lt;key&gt;获得列表长度 linsert &lt;key&gt;  before &lt;value&gt;&lt;newvalue&gt;在&lt;value&gt;的后面插入&lt;newvalue&gt;插入值lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;从左边删除n个value(从左到右)lset&lt;key&gt;&lt;index&gt;&lt;value&gt;将列表key下标为index的值替换成value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-redis集合-Set"><a href="#3-4-redis集合-Set" class="headerlink" title="3.4 redis集合(Set)"></a>3.4 redis集合(Set)</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#set 简介Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的复杂度都是O(1)。一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变#set 简介#set 命令sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ..... 将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略smembers &lt;key&gt;取出该集合的所有值。sismember &lt;key&gt;&lt;value&gt;判断集合&lt;key&gt;是否为含有该&lt;value&gt;值，有1，没有0scard&lt;key&gt;返回该集合的元素个数。srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; .... 删除集合中的某个元素。spop &lt;key&gt;随机从该集合中吐出一个值。srandmember &lt;key&gt;&lt;n&gt;随机从该集合中取出n个值。不会从集合中删除 。smove &lt;source&gt;&lt;destination&gt;value把集合中一个值从一个集合移动到另一个集合sinter &lt;key1&gt;&lt;key2&gt;返回两个集合的交集元素。sunion &lt;key1&gt;&lt;key2&gt;返回两个集合的并集元素。sdiff &lt;key1&gt;&lt;key2&gt;返回两个集合的差集元素(key1中的，不包含key2中的)#set 命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> NOSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rabbitmq</title>
      <link href="/2021/06/29/rabbitmq/"/>
      <url>/2021/06/29/rabbitmq/</url>
      
        <content type="html"><![CDATA[<h1 id="1-消息队列"><a href="#1-消息队列" class="headerlink" title="1. 消息队列"></a><strong>1.</strong> <strong>消息队列</strong></h1><h3 id="1-1-MQ-的相关概念"><a href="#1-1-MQ-的相关概念" class="headerlink" title="1.1. MQ 的相关概念"></a><strong>1.1.</strong> <strong>MQ</strong> <strong>的相关概念</strong></h3><h5 id="1-1-1-什么是MQ"><a href="#1-1-1-什么是MQ" class="headerlink" title="1.1.1. 什么是MQ"></a><strong>1.1.1.</strong> <strong>什么是MQ</strong></h5><pre class="line-numbers language-none"><code class="language-none">MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-1-2-为什么要用MQ及作用"><a href="#1-1-2-为什么要用MQ及作用" class="headerlink" title="1.1.2. 为什么要用MQ及作用"></a><strong>1.1.2.</strong> <strong>为什么要用MQ及作用</strong></h5><pre class="line-numbers language-none"><code class="language-none">1.流量消峰举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210624144959040.png" alt="image-20210624144959040"></p><pre class="line-numbers language-none"><code class="language-none">2.应用解耦以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210624145213648.png" alt="image-20210624145213648"></p><pre class="line-numbers language-none"><code class="language-none">3.异步处理有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210624145417318.png" alt="image-20210624145417318"></p><h5 id="1-1-3-MQ-的分类"><a href="#1-1-3-MQ-的分类" class="headerlink" title="1.1.3. MQ 的分类"></a><strong>1.1.3.</strong> <strong>MQ 的分类</strong></h5><pre class="line-numbers language-none"><code class="language-none">1.ActiveMQ优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较低的概率丢失数据缺点:官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。2.Kafka 大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为大数据而生的消息中间件，以其百万级 TPS 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。 优点: 性能卓越，单机写入 TPS 约在百万条/秒，最大的优点，就是吞吐量高。时效性 ms 级可用性非常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方KafkaWeb 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持： 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用 缺点：Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序，但是一台代理宕机后，就会产生消息乱序，社区更新较慢；3.RocketMQ RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场景。优点:单机吞吐量十万级,可用性非常高，分布式架构,消息可以做到 0 丢失,MQ 功能较为完善，还是分布式的，扩展性好,支持 10 亿级别的消息堆积，不会因为堆积导致性能下降,源码是 java 我们可以自己阅读源码，定制自己公司的 MQ 缺点：支持的客户端语言不多，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在MQ核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码4.RabbitMQ 2007 年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。 优点:由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，MQ 功能比较完备,健壮、稳定、易用、跨平台、支持多种语言 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用,社区活跃度高；更新频率相当高https://www.rabbitmq.com/news.html 缺点：商业版需要收费,学习成本较高<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-1-4-MQ-的选择"><a href="#1-1-4-MQ-的选择" class="headerlink" title="1.1.4. MQ 的选择"></a><strong>1.1.4.</strong> <strong>MQ 的选择</strong></h5><pre class="line-numbers language-none"><code class="language-none">1.Kafka Kafka 主要特点是基于Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能，肯定是首选 kafka 了。2.RocketMQ天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。3.RabbitMQ 结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分方便，如果你的数据量没有那么大，中小型公司优先选择功能比较完备的 RabbitMQ。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-RabbitMQ"><a href="#1-2-RabbitMQ" class="headerlink" title="1.2. RabbitMQ"></a><strong>1.2.</strong> <strong>RabbitMQ</strong></h3><h5 id="1-2-1-RabbitMQ-的概念"><a href="#1-2-1-RabbitMQ-的概念" class="headerlink" title="1.2.1. RabbitMQ 的概念"></a><strong>1.2.1.</strong> <strong>RabbitMQ 的概念</strong></h5><pre class="line-numbers language-none"><code class="language-none">RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-2-四大核心概念"><a href="#1-2-2-四大核心概念" class="headerlink" title="1.2.2. 四大核心概念"></a><strong>1.2.2.</strong> <strong>四大核心概念</strong></h5><pre class="line-numbers language-none"><code class="language-none">生产者产生数据发送消息的程序是生产者交换机交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定队列队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式消费者消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210624150546420.png" alt="image-20210624150546420"></p><h5 id="1-2-3-RabbitMQ-核心部分"><a href="#1-2-3-RabbitMQ-核心部分" class="headerlink" title="1.2.3. RabbitMQ 核心部分"></a><strong>1.2.3.</strong> <strong>RabbitMQ 核心部分</strong></h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">--</span>简单模式<span class="token operator">--</span>工作模式<span class="token operator">--</span>发布<span class="token operator">/</span>订阅模式<span class="token operator">--</span>路由模式<span class="token operator">--</span>主题模式<span class="token operator">--</span>发布确认模式    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210624150753397.png" alt="image-20210624150753397"></p><h5 id="1-2-4-各个名词介绍"><a href="#1-2-4-各个名词介绍" class="headerlink" title="1.2.4. 各个名词介绍"></a><strong>1.2.4.</strong> <strong>各个名词介绍</strong></h5><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210624150916192.png" alt="image-20210624150916192"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Broker</span>：接收和分发消息的应用，<span class="token class-name">RabbitMQ</span> <span class="token class-name">Server</span> 就是 <span class="token class-name">Message</span> <span class="token class-name">Broker</span>    <span class="token class-name">Virtual</span> host：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 <span class="token class-name">RabbitMQ</span> server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等    <span class="token class-name">Connection</span>：publisher／consumer 和 broker 之间的 TCP 连接    <span class="token class-name">Channel</span>：如果每一次访问 <span class="token class-name">RabbitMQ</span> 都建立一个 <span class="token class-name">Connection</span>，在消息量大的时候建立 TCP <span class="token class-name">Connection</span> 的开销将是巨大的，效率也较低。<span class="token class-name">Channel</span> 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。<span class="token class-name">Channel</span> 作为轻量级的<span class="token class-name">Connection</span> 极大减少了操作系统建立 TCP connection 的开销     <span class="token class-name">Exchange</span>：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct <span class="token punctuation">(</span>point<span class="token operator">-</span><span class="token keyword">to</span><span class="token operator">-</span>point<span class="token punctuation">)</span><span class="token punctuation">,</span> topic <span class="token punctuation">(</span>publish<span class="token operator">-</span>subscribe<span class="token punctuation">)</span> and fanout<span class="token punctuation">(</span>multicast<span class="token punctuation">)</span>    <span class="token class-name">Queue</span>：消息最终被送到这里等待 consumer 取走    <span class="token class-name">Binding</span>：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，<span class="token class-name">Binding</span> 信息被保存到 exchange 中的查询表中，用于 message 的分发依据 <span class="token operator">--</span><span class="token class-name">Exchange</span>与<span class="token class-name">Queue</span>的连线<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-5-安装"><a href="#1-2-5-安装" class="headerlink" title="1.2.5. 安装"></a><strong>1.2.5.</strong> <strong>安装</strong></h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemctl start dockersystemctl enable docker  #设置docker开机自启docker start 容器iddocker pull rabbitmq:managementdocker run -dit --name my-rabbitmq -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 rabbitmq:management#web 访问地址 ifconfig:15672# lsof -i:15672  查看指定端口是否开放--systemctl status firewalld--systemctl firewalld start(restart stop)--firewall-cmd --list-ports--firewall-cmd --zone=public --add-port=80/tcp --permanent<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">#阿里云镜像加速sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{  "registry-mirrors": ["https://1vbbrszu.mirror.aliyuncs.com"]}EOFsudo systemctl daemon-reloadsudo systemctl restart docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-Work-Queues"><a href="#2-Work-Queues" class="headerlink" title="2. Work Queues"></a><strong>2.</strong> <strong>Work Queues</strong></h1><pre class="line-numbers language-java" data-language="java"><code class="language-java">生产者大量消息发送给队列<span class="token operator">-&gt;</span>多个工资线程处理 消息只能被处理一次<span class="token operator">--</span>轮询<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210628090012030.png" alt="image-20210628090012030"></p><h3 id="2-1-消息应答"><a href="#2-1-消息应答" class="headerlink" title="2.1. 消息应答"></a><strong>2.1.</strong> <strong>消息应答</strong></h3><h5 id="2-1-1-概念"><a href="#2-1-1-概念" class="headerlink" title="2.1.1. 概念"></a><strong>2.1.1.</strong> <strong>概念</strong></h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。<span class="token class-name">RabbitMQ</span> 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费这的消息，因为它无法接收到。为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制，消息应答就是<span class="token operator">:</span>消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。<span class="token operator">--</span>应该rabbitmq回答后进行删除        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="2-1-1-自动应答"><a href="#2-1-1-自动应答" class="headerlink" title="2.1.1. 自动应答"></a><strong>2.1.1.</strong> <strong>自动应答</strong></h5><pre class="line-numbers language-none"><code class="language-none">这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用。不适应高吞吐量和数据传输安全性方面<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-1-2-手动应答"><a href="#2-1-2-手动应答" class="headerlink" title="2.1.2. 手动应答"></a><strong>2.1.2.</strong> <strong>手动应答</strong></h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">--</span><span class="token class-name">A</span><span class="token operator">:</span><span class="token class-name">Channel</span><span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>用于肯定确认<span class="token punctuation">)</span>  <span class="token class-name">RabbitMQ</span> 已知道该消息并且成功的处理消息，可以将其丢弃了<span class="token operator">--</span><span class="token class-name">B</span><span class="token operator">:</span><span class="token class-name">Channel</span><span class="token punctuation">.</span><span class="token function">basicNack</span><span class="token punctuation">(</span>用于否定确认<span class="token punctuation">)</span> <span class="token operator">--</span><span class="token class-name">C</span><span class="token operator">:</span><span class="token class-name">Channel</span><span class="token punctuation">.</span><span class="token function">basicReject</span><span class="token punctuation">(</span>用于否定确认<span class="token punctuation">)</span> 与 <span class="token class-name">Channel</span><span class="token punctuation">.</span>basicNack 相比少一个参数 <span class="token punctuation">(</span><span class="token class-name">Multiple</span>批量处理<span class="token punctuation">)</span> 不处理该消息了直接拒绝，可以将其丢弃了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-1-3-Multiple批量参数"><a href="#2-1-3-Multiple批量参数" class="headerlink" title="2.1.3. Multiple批量参数"></a><strong>2.1.3.</strong> <strong>Multiple批量参数</strong></h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">--</span>手动应答的好处是可以批量应答并且减少网络拥堵  channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>deliveryTag<span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210628100618363.png" alt="image-20210628100618363"></p><h5 id="2-1-4-重新入队-已丢失"><a href="#2-1-4-重新入队-已丢失" class="headerlink" title="2.1.4. 重新入队(已丢失)"></a><strong>2.1.4.</strong> <strong>重新入队(已丢失)</strong></h5><pre class="line-numbers language-none"><code class="language-none">--消息已丢失。(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-2-RabbitMQ-持久化"><a href="#2-2-RabbitMQ-持久化" class="headerlink" title="2.2. RabbitMQ 持久化"></a><strong>2.2. RabbitMQ 持久化</strong></h3><h5 id="2-2-1-概念"><a href="#2-2-1-概念" class="headerlink" title="2.2.1. 概念"></a><strong>2.2.1.</strong> <strong>概念</strong></h5><pre class="line-numbers language-none"><code class="language-none">保障当 RabbitMQ 服务停掉以后消息生产者发送过来的消息不丢失。默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：我们需要将队列和消息都标记为持久化。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="2-2-2-队列实现持久化"><a href="#2-2-2-队列实现持久化" class="headerlink" title="2.2.2. 队列实现持久化"></a><strong>2.2.2.</strong> <strong>队列实现持久化</strong></h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">--</span>声明队列时 durable<span class="token operator">--</span>如之前队列不是 durable <span class="token punctuation">,</span>需删除重新创建一个durable队列               <span class="token comment">/**             * 生成一个队列             * 1.队列名称             * 2.队列里面的消息是否持久化(磁盘) 默认消息存储在内存中 源码:持久队列             * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费             * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除             * 5.其他参数             */</span>            channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>TASK_QUEUE_NAME<span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210629094006956.png" alt="image-20210629094006956"></p><h5 id="2-2-3-消息实现持久化"><a href="#2-2-3-消息实现持久化" class="headerlink" title="2.2.3. 消息实现持久化"></a><strong>2.2.3.</strong> <strong>消息实现持久化</strong></h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">--</span>生产者发送消息时<span class="token operator">--</span>只是告诉消息队列尽量保存到磁盘<span class="token operator">--</span> 发布<span class="token operator">/</span>确认 持久化策略<span class="token operator">--</span><span class="token class-name">MessageProperties</span><span class="token punctuation">.</span>PERSISTENT_TEXT_PLAIN                    <span class="token comment">/**                 * 发送一个消息                 * 1.发送到那个交换机                 * 2.路由的 key 是哪个                 * 3.其他的参数信息                 * 4.发送消息的消息体                 * 字符串转二进制                 */</span>channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span>QUEUE_NAME<span class="token punctuation">,</span><span class="token class-name">MessageProperties</span><span class="token punctuation">.</span>PERSISTENT_TEXT_PLAIN<span class="token punctuation">,</span>message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2-4-不公平分发"><a href="#2-2-4-不公平分发" class="headerlink" title="2.2.4. 不公平分发"></a><strong>2.2.4.</strong> <strong>不公平分发</strong></h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">RabbitMQ</span> 分发消息采用的轮训分发，但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个消费者 <span class="token number">1</span> 处理任务的速度非常快，而另外一个消费者 <span class="token number">2</span>处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是<span class="token class-name">RabbitMQ</span> 并不知道这种情况它依然很公平的进行分发。<span class="token comment">//消费者端更改</span>channel<span class="token punctuation">.</span><span class="token function">basicQos</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2-5-预取值分发"><a href="#2-2-5-预取值分发" class="headerlink" title="2.2.5.预取值分发"></a><strong>2.2.5.预取值分发</strong></h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//大于1就是预取值分发</span>channel<span class="token punctuation">.</span><span class="token function">basicQos</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>channel<span class="token punctuation">.</span><span class="token function">basicQos</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210701090505297.png" alt="image-20210701090505297"></p><h1 id="3-发布确认"><a href="#3-发布确认" class="headerlink" title="3. 发布确认"></a><strong>3. 发布确认</strong></h1><h3 id="3-1-发布确认的策略"><a href="#3-1-发布确认的策略" class="headerlink" title="3.1. 发布确认的策略"></a><strong>3.1. 发布确认的策略</strong></h3><pre class="line-numbers language-none"><code class="language-none">生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息，生产者应用程序同样可以在回调方法中处理该 nack 消息。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">发布确认保证消息不丢失<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210705201015479.png" alt="image-20210705201015479"></p><h5 id="3-1-1-开启发布确认"><a href="#3-1-1-开启发布确认" class="headerlink" title="3.1.1. 开启发布确认"></a><strong>3.1.1.</strong> <strong>开启发布确认</strong></h5><pre class="line-numbers language-none"><code class="language-none">发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布确认，都需要在 channel 上调用该方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//开启发布确认</span>channel<span class="token punctuation">.</span><span class="token function">confirmSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="3-1-2-单个确认发布"><a href="#3-1-2-单个确认发布" class="headerlink" title="3.1.2. **单个确认发布 **"></a><strong>3.1.2.</strong> **单个确认发布 **</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">这是一种简单的确认方式，它是一种同步确认发布的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布<span class="token punctuation">,</span><span class="token function">waitForConfirmsOrDie</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。这种确认方式有一个最大的缺点就是<span class="token operator">:</span>发布速度特别的慢，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span>queueName<span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span>message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//单个消息确认</span><span class="token keyword">boolean</span> b <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">waitForConfirms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="3-1-3-批量确认发布"><a href="#3-1-3-批量确认发布" class="headerlink" title="3.1.3. **批量确认发布 **"></a><strong>3.1.3.</strong> **批量确认发布 **</h5><pre class="line-numbers language-none"><code class="language-none">缺点就是:当发生故障导致发布出现问题时，不知道是哪个消息出现问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布与单个确认代码一致，只是不再一条条确认，而是根据条件批量确认一次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="3-1-4-异步确认发布"><a href="#3-1-4-异步确认发布" class="headerlink" title="3.1.4. **异步确认发布 **"></a><strong>3.1.4.</strong> **异步确认发布 **</h5><pre class="line-numbers language-none"><code class="language-none">异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说，他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功--根据编号,不在考虑是否成功，全靠broker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210705204303643.png" alt="image-20210705204303643"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//消息确认成功</span> <span class="token class-name">ConfirmCallback</span>  ackCallback<span class="token operator">=</span> <span class="token punctuation">(</span> deliveryTag<span class="token punctuation">,</span>multiple<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消息确认成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">/**  * 消息的标记  * 是否批量确认  */</span> <span class="token class-name">ConfirmCallback</span>  nackCallback<span class="token operator">=</span> <span class="token punctuation">(</span>deliveryTag<span class="token punctuation">,</span>multiple<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"未确认消息"</span><span class="token operator">+</span>deliveryTag<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//消息的监听器 监听成功失败</span> channel<span class="token punctuation">.</span><span class="token function">addConfirmListener</span><span class="token punctuation">(</span>ackCallback<span class="token punctuation">,</span>nackCallback<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>失败回调</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ConcurrentLinkedQueue</span> 在发消息时进行全部标记的记录确认时筛选所有已接收记录的标记，剩下就是未确认<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**      * 线程安全有序的哈希表      */</span>     <span class="token class-name">ConcurrentSkipListMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> skipListMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentSkipListMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//消息确认成功</span>     <span class="token class-name">ConfirmCallback</span>  ackCallback<span class="token operator">=</span> <span class="token punctuation">(</span> deliveryTag<span class="token punctuation">,</span>multiple<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>         <span class="token comment">//删除已确认的</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>multiple<span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token class-name">ConcurrentNavigableMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> headMap <span class="token operator">=</span> skipListMap<span class="token punctuation">.</span><span class="token function">headMap</span><span class="token punctuation">(</span>deliveryTag<span class="token punctuation">)</span><span class="token punctuation">;</span>             headMap<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>             skipListMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>deliveryTag<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消息确认成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token comment">/**      * 消息的标记      * 是否批量确认      */</span>     <span class="token class-name">ConfirmCallback</span>  nackCallback<span class="token operator">=</span> <span class="token punctuation">(</span>deliveryTag<span class="token punctuation">,</span>multiple<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>         <span class="token class-name">String</span> s <span class="token operator">=</span> skipListMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>deliveryTag<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"未确认消息"</span><span class="token operator">+</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token comment">//消息的监听器 监听成功失败</span>     channel<span class="token punctuation">.</span><span class="token function">addConfirmListener</span><span class="token punctuation">(</span>ackCallback<span class="token punctuation">,</span>nackCallback<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//异步发消息</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token class-name">String</span> message<span class="token operator">=</span>i<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">;</span>         channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span>queueName<span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span>message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//记录所有标记 消息的总和</span>         skipListMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">getNextPublishSeqNo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-交换机"><a href="#4-交换机" class="headerlink" title="4. 交换机"></a><strong>4. 交换机</strong></h1><h3 id="4-1-发布订阅模式"><a href="#4-1-发布订阅模式" class="headerlink" title="4.1 发布订阅模式"></a>4.1 发布订阅模式</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">队列中消息只能让消息消费一次    交换机绑定多个队列 来实现一个消息多个消费者消费    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210707163337649.png" alt="image-20210707163337649"></p><h5 id="4-1-1-Exchanges概念及类型"><a href="#4-1-1-Exchanges概念及类型" class="headerlink" title="4.1.1. Exchanges概念及类型"></a><strong>4.1.1.</strong> <strong>Exchanges概念及类型</strong></h5><pre class="line-numbers language-none"><code class="language-none">RabbitMQ 消息传递模型的核心思想是: 生产者生产的消息从不会直接发送到队列。生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">默认交换机<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>AMQP <span class="token keyword">default</span>    不知道routingKey 队列名称直接<span class="token punctuation">(</span>direct<span class="token punctuation">)</span>主题<span class="token punctuation">(</span>topic<span class="token punctuation">)</span>标题<span class="token punctuation">(</span>headers<span class="token punctuation">)</span> 扇出<span class="token punctuation">(</span>fanout<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>临时队列</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//2种创建方式,不持久化的队列</span>            <span class="token comment">/**             * 生成一个队列             * 1.队列名称             * 2.队列里面的消息是否持久化(磁盘) 默认消息存储在内存中 源码:持久队列             * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费             * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除             * 5.其他参数             */</span> channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>TASK_QUEUE_NAME<span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-1-2-bindngs绑定"><a href="#4-1-2-bindngs绑定" class="headerlink" title="4.1.2 bindngs绑定"></a>4.1.2 bindngs绑定</h5><pre class="line-numbers language-none"><code class="language-none">根据routingKey区分发送到那个队列<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210707184952010.png" alt="image-20210707184952010"></p><h3 id="4-2-fanout模式"><a href="#4-2-fanout模式" class="headerlink" title="4.2 fanout模式"></a>4.2 fanout模式</h3><pre class="line-numbers language-none"><code class="language-none">将接收到的所有消息广播到它知道的所有队列中 routingKey相同<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//生产者</span>channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span>EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//消费者</span><span class="token comment">//声明交换机名称及类型</span>channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span>EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token string">"fanout"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/**         * 交换机与队列捆绑         * 1.队列名称         * 2.交换机名称         * 3.routingkey         */</span>channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> deliverCallback<span class="token punctuation">,</span> consumerTag <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-direct模式"><a href="#4-3-direct模式" class="headerlink" title="4.3 direct模式"></a>4.3 direct模式</h3><pre class="line-numbers language-none"><code class="language-none">routingKey不同<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-3-topic模式"><a href="#4-3-topic模式" class="headerlink" title="4.3 topic模式"></a>4.3 topic模式</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">direct模式局限性<span class="token operator">:</span>只能路由一个交换机，可以绑定多个，但无法发送多个队列topic模式可发送多个队列        发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是一个单词列表，以点号分隔开。这些单词可以是任意单词，比如说：<span class="token string">"stock.usd.nyse"</span><span class="token punctuation">,</span><span class="token string">"nyse.vmw"</span><span class="token punctuation">,</span><span class="token string">"quick.orange.rabbit"</span><span class="token punctuation">.</span>这种类型的。当然这个单词列表最多不能超过 <span class="token number">255</span> 个字节。    <span class="token operator">*</span><span class="token punctuation">(</span>星号<span class="token punctuation">)</span>可以代替一个单词#<span class="token punctuation">(</span>井号<span class="token punctuation">)</span>可以替代零个或多个单词如下图<span class="token operator">:</span> Q1<span class="token operator">--</span><span class="token operator">&gt;</span>绑定的是中间带 orange 带 <span class="token number">3</span> 个单词的字符串<span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">.</span>orange<span class="token punctuation">.</span>*<span class="token punctuation">)</span>Q2<span class="token operator">--</span><span class="token operator">&gt;</span>绑定的是最后一个单词是 rabbit 的 <span class="token number">3</span> 个单词<span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">.</span>*<span class="token punctuation">.</span>rabbit<span class="token punctuation">)</span>第一个单词是 lazy 的多个单词<span class="token punctuation">(</span>lazy<span class="token punctuation">.</span>#<span class="token punctuation">)</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210707204316143.png" alt="image-20210707204316143"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span>EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token string">"topic"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="5-死信队列"><a href="#5-死信队列" class="headerlink" title="5. 死信队列"></a><strong>5. 死信队列</strong></h1><h3 id="5-1-死信架构"><a href="#5-1-死信架构" class="headerlink" title="5.1 死信架构"></a>5.1 死信架构</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">无法被消费的消息producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。应用场景<span class="token operator">:</span>为了保证订单业务的消息数据不丢失，需要使用到 <span class="token class-name">RabbitMQ</span> 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中<span class="token punctuation">.</span>还有比如说<span class="token operator">:</span> 用户在商城下单成功并点击去支付后在指定时间未支付时自动失效<span class="token operator">--</span>死信来源 消息 TTL 过期队列达到最大长度<span class="token punctuation">(</span>队列满了，无法再添加数据到 mq 中<span class="token punctuation">)</span>消息被拒绝<span class="token punctuation">(</span>basic<span class="token punctuation">.</span>reject 或 basic<span class="token punctuation">.</span>nack<span class="token punctuation">)</span>并且 requeue<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">.</span><span class="token operator">--</span>死信队列type<span class="token operator">=</span>direct<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210708111644518.png" alt="image-20210708111644518"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">--</span><span class="token class-name">Consumer</span><span class="token comment">//声明死信和普通交换机 类型为 direct</span>        channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span>NORMAL_EXCHANGE<span class="token punctuation">,</span> <span class="token class-name">BuiltinExchangeType</span><span class="token punctuation">.</span>DIRECT<span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span>DEAD_EXCHANGE<span class="token punctuation">,</span> <span class="token class-name">BuiltinExchangeType</span><span class="token punctuation">.</span>DIRECT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//声明死信队列</span>        <span class="token class-name">String</span> deadQueue <span class="token operator">=</span> <span class="token string">"dead-queue"</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>deadQueue<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//死信队列绑定死信交换机与 routingkey</span>        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span>deadQueue<span class="token punctuation">,</span> DEAD_EXCHANGE<span class="token punctuation">,</span> <span class="token string">"lisi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//正常队列绑定死信队列信息</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> params <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//死信队列设置过期时间 可在生产或消费者2处设置 建议在生产者端控制</span><span class="token comment">//params.put("x-message-ttl", 10000);</span><span class="token comment">//正常队列设置死信交换机 参数 key 是固定值</span>        params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-exchange"</span><span class="token punctuation">,</span> DEAD_EXCHANGE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//正常队列设置死信 routing-key 参数 key 是固定值</span>        params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-routing-key"</span><span class="token punctuation">,</span> <span class="token string">"lisi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> normalQueue <span class="token operator">=</span> <span class="token string">"normal-queue"</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>normalQueue<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span>normalQueue<span class="token punctuation">,</span> NORMAL_EXCHANGE<span class="token punctuation">,</span> <span class="token string">"zhangsan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-死信3大来源"><a href="#5-2-死信3大来源" class="headerlink" title="5.2 死信3大来源"></a>5.2 死信3大来源</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//消息 TTL 过期，队列达到最大长度，消息被拒绝 设置</span><span class="token operator">--</span><span class="token class-name">Producer</span>    <span class="token comment">//设置消息的 TTL 时间</span>        <span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties</span> properties <span class="token operator">=</span>                       <span class="token keyword">new</span> <span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expiration</span><span class="token punctuation">(</span><span class="token string">"10000"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span>NORMAL_EXCHANGE<span class="token punctuation">,</span> <span class="token string">"zhangsan"</span><span class="token punctuation">,</span>properties<span class="token punctuation">,</span>message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token class-name">Consumer</span>    <span class="token comment">//  params.put("x-message-ttl", 10000);</span>    <span class="token comment">//队列达到最大长度</span><span class="token operator">--</span><span class="token class-name">Consumer</span>     params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-max-length"</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//消息被拒绝</span>        <span class="token class-name">DeliverCallback</span> deliverCallback <span class="token operator">=</span> <span class="token punctuation">(</span>consumerTag<span class="token punctuation">,</span> delivery<span class="token punctuation">)</span> <span class="token operator">-&gt;</span>        <span class="token punctuation">{</span><span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>delivery<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"info5"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment">/**                 * 当前队列的标记                 * true重新排队,进去死信                 */</span>                channel<span class="token punctuation">.</span><span class="token function">basicReject</span><span class="token punctuation">(</span>delivery<span class="token punctuation">.</span><span class="token function">getEnvelope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">/**                 * 当前队列的标记                 * true拒绝所有标签                 */</span>                <span class="token comment">//channel.basicNack(delivery.getEnvelope().getDeliveryTag(),false,false);</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"此消息是被拒绝掉的"</span><span class="token operator">+</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-延迟队列"><a href="#5-3-延迟队列" class="headerlink" title="5.3 延迟队列"></a>5.3 延迟队列</h3><pre class="line-numbers language-none"><code class="language-none">延迟队列其实就是基于死信队列的ttl过期延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>延迟使用场景</p></blockquote><pre class="line-numbers language-none"><code class="language-none">1.订单在十分钟之内未支付则自动取消2.新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。3.用户注册成功后，如果三天内没有登陆则进行短信提醒。4.用户发起退款，如果三天内没有得到处理则通知相关运营人员。5.预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如：发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；看起来似乎使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？如果数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求，如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210708143638523.png" alt="image-20210708143638523"></p><h3 id="5-4-整合springboot"><a href="#5-4-整合springboot" class="headerlink" title="5.4 整合springboot"></a><strong>5.4 整合springboot</strong></h3><pre class="line-numbers language-none"><code class="language-none">原先交换机队列死信队列 绑定关系 都由消费者来承担维护，现在都由配置类来完成创建<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210708145512282.png" alt="image-20210708145512282"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">--</span>配置类 完成交换机 队列 及绑定的相关操作<span class="token number">1.</span>声明交换机    <span class="token number">2.</span>声明队列<span class="token class-name">Queue</span><span class="token comment">//QueueBuilder.durable(QUEUE_A).withArguments(args).build();</span>    <span class="token number">3.</span>绑定队列与交换机及key<span class="token comment">//BindingBuilder.bind(queueA).to(xExchange).with("XA");</span><span class="token operator">--</span>生产者    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"X"</span><span class="token punctuation">,</span> <span class="token string">"XA"</span><span class="token punctuation">,</span> <span class="token string">"消息来自 ttl 为 10S 的队列: "</span><span class="token operator">+</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span>消费者<span class="token punctuation">(</span>监听者<span class="token punctuation">)</span>    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"QD"</span><span class="token punctuation">)</span> <span class="token comment">//监听指定队列</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210708203207093.png" alt="image-20210708203207093"></p><h3 id="5-5-优化代码及死信缺陷"><a href="#5-5-优化代码及死信缺陷" class="headerlink" title="5.5 优化代码及死信缺陷"></a>5.5 优化代码及死信缺陷</h3><pre class="line-numbers language-none"><code class="language-none">生产者来指定时间的传递，而不是在队列中定死。通用队列死信缺陷：--RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列，如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="5-6-基于插件解决死信缺陷"><a href="#5-6-基于插件解决死信缺陷" class="headerlink" title="5.6 基于插件解决死信缺陷"></a>5.6 基于插件解决死信缺陷</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>com<span class="token operator">/</span>community<span class="token operator">-</span>plugins<span class="token punctuation">.</span>htmlrabbitmq_delayed_message_exchangehttps<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>rabbitmq<span class="token operator">/</span>rabbitmq<span class="token operator">-</span>delayed<span class="token operator">-</span>message<span class="token operator">-</span>exchange    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>docker安装</p></blockquote><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">#上传到内部容器的plugins中docker exec -it 5283d4d3cfe0 /bin/bash#复制到容器内docker cp rabbitmq_delayed_message_exchange-3.8.17.8f537ac.ez 5283d4d3cfe0:/plugins#启动安装rabbitmq-plugins enable rabbitmq_delayed_message_exchange#重启docker restart 5283d4d3cfe0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>延迟插件</p></blockquote><pre class="line-numbers language-none"><code class="language-none">基于死信的是在队列控制，而基于插件的是在交换机控制更简洁了延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为单个节点挂掉导致延时队列不可用或者消息丢失。延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz或者利用 kafka 的时间轮，这些方式各有特点,看需要适用的场景。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210714204140345.png" alt="image-20210714204140345"></p><h1 id="5-发布确认高级"><a href="#5-发布确认高级" class="headerlink" title="5. 发布确认高级"></a><strong>5. 发布确认高级</strong></h1><pre class="line-numbers language-none"><code class="language-none">在生产环境中由于一些不明原因，导致 rabbitmq 重启，在 RabbitMQ 重启期间生产者消息投递失败，导致消息丢失，需要手动处理和恢复。于是，我们开始思考，如何才能进行 RabbitMQ 的消息可靠投递呢？ 特别是在这样比较极端的情况，RabbitMQ 集群不可用的时候，无法投递的消息该如何处理呢--需要一个消息回调来确认mq是否接收到了发送的消息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5-1-交换机回调接口"><a href="#5-1-交换机回调接口" class="headerlink" title="5.1  交换机回调接口"></a>5.1  交换机回调接口</h3><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">#yml配置启动⚫ NONE禁用发布确认模式，是默认值⚫ CORRELATED发布消息成功到交换器后会触发回调方法⚫ SIMPLE经测试有两种效果，其一效果和 CORRELATED 值一样会触发回调方法，其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 brokerspring:  rabbitmq:    publisher-confirm-type: correlated<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">就算集群，也要做好最坏措施，当mq全部不能使用时，使用回调接口，保证消息能够回来，不丢失<span class="token annotation punctuation">@Component</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyCallBack</span> <span class="token keyword">implements</span> <span class="token class-name">RabbitTemplate<span class="token punctuation">.</span>ConfirmCallback</span><span class="token punctuation">{</span>    <span class="token comment">//</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RabbitTemplate</span> rabbitTemplate<span class="token punctuation">;</span>    <span class="token comment">//注入自定义方法 因为是自己实现所有还需要初始化注入进去调用</span>    <span class="token comment">//PostConstruct 注解用于需要在依赖注入完成后执行任何初始化的方法 最先执行MyCallBack -》RabbitTemplate -》@PostConstruct  否则set值会null值异常</span>    <span class="token annotation punctuation">@PostConstruct</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">setConfirmCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token comment">/**     * @Author: lml     * @Date: 2021/7/16 15:46     * @param correlationData:保存回调消息的id及相关信息 由生产者发送过来 convertAndSend重载     * @param ack:交换机是否收到消息 true     * @param cause:cause原因-null 成功(null)失败原因     * @return: void     **/</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">confirm</span><span class="token punctuation">(</span><span class="token class-name">CorrelationData</span> correlationData<span class="token punctuation">,</span> <span class="token keyword">boolean</span> ack<span class="token punctuation">,</span> <span class="token class-name">String</span> cause<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> id <span class="token operator">=</span>correlationData<span class="token operator">!=</span><span class="token keyword">null</span><span class="token operator">?</span>correlationData<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ack<span class="token punctuation">)</span><span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"交换机已经收到了id为:{}的消息"</span><span class="token punctuation">,</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"交换机还没收到id未:{}的消息,由于:{}原因"</span><span class="token punctuation">,</span>id<span class="token punctuation">,</span>cause<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-队列回退消息"><a href="#5-2-队列回退消息" class="headerlink" title="5.2  队列回退消息"></a>5.2  队列回退消息</h3><pre class="line-numbers language-none"><code class="language-none">在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现该消息不可路由(无法转到指定队列)，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。通过设置 mandatory 参数可以在当消息传递过程中不可达目的地时将消息返回给生产者。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">#启动队列发布退回spring:  rabbitmq:    publisher-returns: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyCallBack</span> <span class="token keyword">implements</span> <span class="token class-name">RabbitTemplate<span class="token punctuation">.</span>ReturnsCallback</span><span class="token punctuation">{</span>          <span class="token comment">//注入自定义方法</span>    <span class="token annotation punctuation">@PostConstruct</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">setConfirmCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">setReturnsCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-备份交换机"><a href="#5-3-备份交换机" class="headerlink" title="5.3 备份交换机"></a>5.3 备份交换机</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，有机会在生产者的消息无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失息，又不想增加生产者的复杂性，该怎么做呢？前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。在 <span class="token class-name">RabbitMQ</span> 中，有一种备份交换机的机制存在，可以很好的应对这个问题。什么是备份交换机呢？备份交换机可以理解为 <span class="token class-name">RabbitMQ</span> 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时，就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理，通常备份交换机的类型为 <span class="token class-name">Fanout</span> ，这样就能把所有消息都投递到与其绑定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。<span class="token number">1.</span>可以不用使用<span class="token number">5.1</span>和<span class="token number">5.2</span>的回调回退方法而使用备份交换机来解决消息不可达或交换机错误  <span class="token number">1.1</span><span class="token operator">:</span>回调回退方法不知道该如何处理这些无法路由的消息，最多打个日志<span class="token number">2.</span>不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息<span class="token number">3.</span>备份交换机的机制<span class="token punctuation">,</span>类型为 <span class="token class-name">Fanout</span><span class="token number">4.</span>好处<span class="token operator">:</span>我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210716165212059.png" alt="image-20210716165212059"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">  <span class="token comment">//设置确认交换机绑定备份交换机</span>  <span class="token comment">//备份交换机优先级高。</span><span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"confirmExchange"</span><span class="token punctuation">)</span>   <span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">confirmExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token class-name">ExchangeBuilder</span> exchangeBuilder <span class="token operator">=</span> <span class="token class-name">ExchangeBuilder</span><span class="token punctuation">.</span><span class="token function">directExchange</span><span class="token punctuation">(</span>CONFIRM_EXCHANGE_NAME<span class="token punctuation">)</span>                   <span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>                   <span class="token punctuation">.</span><span class="token function">withArgument</span><span class="token punctuation">(</span><span class="token string">"alternate-exchange"</span><span class="token punctuation">,</span> BACKUP_EXCHANGE_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">DirectExchange</span><span class="token punctuation">)</span>exchangeBuilder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="6-mq重复消费"><a href="#6-mq重复消费" class="headerlink" title="6.mq重复消费"></a>6.mq重复消费</h1><h3 id="6-1-幂等性"><a href="#6-1-幂等性" class="headerlink" title="6.1 幂等性"></a>6.1 幂等性</h3><pre class="line-numbers language-none"><code class="language-none">用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>mq消息重复消费</p></blockquote><pre class="line-numbers language-none"><code class="language-none">消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给MQ 返回 ack 时网络中断，故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>解决方案</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">--</span>唯一<span class="token function">id</span><span class="token punctuation">(</span>mq的该id<span class="token punctuation">)</span>先判断该消息是否已消费过。<span class="token operator">--</span>a<span class="token punctuation">.</span>唯一 ID<span class="token operator">+</span>指纹码机制<span class="token punctuation">,</span>利用数据库主键去重<span class="token punctuation">,</span> b<span class="token punctuation">.</span>利用 redis 的原子性去实现        指纹码<span class="token operator">:</span>我们的一些规则或者时间戳加别的服务给到的唯一信息码<span class="token punctuation">,</span>它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id 是否存在数据库中<span class="token punctuation">,</span>优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。    利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="7-优先级队列"><a href="#7-优先级队列" class="headerlink" title="7.优先级队列"></a>7.优先级队列</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//优先级队列 0-255 越大越优先</span>在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单<span class="token punctuation">,</span>淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧，但是，tmall商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存放的定时轮询，大家都知道 redis 只能用 <span class="token class-name">List</span> 做一个简简单单的消息队列，并不能实现一个优先级的场景，所以订单量大了后采用 <span class="token class-name">RabbitMQ</span> 进行改造和优化<span class="token punctuation">,</span>如果发现是大客户的订单给一个相对比较高的优先级，否则就是默认优先级。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">--</span>队列需要设置为优先级队列，消息需要设置消息的优先级<span class="token operator">--</span>springboot  rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token class-name">DelayedQueueConfig</span><span class="token punctuation">.</span>DELAYED_EXCHANGE_NAME<span class="token punctuation">,</span> <span class="token class-name">DelayedQueueConfig</span><span class="token punctuation">.</span>DELAYED_ROUTING_KEY<span class="token punctuation">,</span> message<span class="token punctuation">,</span>                <span class="token comment">//设置延迟优先级</span>                msg <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>                    msg<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setDelay</span><span class="token punctuation">(</span>delayTime<span class="token punctuation">)</span><span class="token punctuation">;</span>                    msg<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> msg<span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">--</span>java  <span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties</span> properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">priority</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span>QUEUE_NAME<span class="token punctuation">,</span>properties<span class="token punctuation">,</span>message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="8-惰性队列"><a href="#8-惰性队列" class="headerlink" title="8.惰性队列"></a>8.惰性队列</h1><pre class="line-numbers language-none"><code class="language-none">消息保存内存中还是在磁盘中正常:内存惰性:磁盘 (先去在磁盘-&gt;内存在消费)场景:消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">--</span>java<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> args <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>args<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-queue-mode"</span><span class="token punctuation">,</span> <span class="token string">"lazy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span><span class="token string">"myqueue"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span>springboot     <span class="token comment">//声明队列</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"queueC"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">queueC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> args <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//声明当前队列绑定的死信交换机</span>        args<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-exchange"</span><span class="token punctuation">,</span> Y_DEAD_LETTER_EXCHANGE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//声明当前队列的死信路由 key</span>        args<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-routing-key"</span><span class="token punctuation">,</span> <span class="token string">"YD"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        args<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-queue-mode"</span><span class="token punctuation">,</span> <span class="token string">"lazy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span><span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span>QUEUE_C<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withArguments</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token operator">--</span>             <span class="token class-name">QueueBuilder</span><span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="9-mq集群"><a href="#9-mq集群" class="headerlink" title="9.mq集群"></a>9.mq集群</h1><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">--linux 版#修改每个主机机器名称 在重启vim /etc/hostname#设置每个所有集群ip --ip名 hostnamevim /etc/hosts10.211.55.74 node110.211.55.75 node210.211.55.76 node3#cookie一致 以node1远程copy替换scp /var/lib/rabbitmq/.erlang.cookie root@node2:/var/lib/rabbitmq/.erlang.cookiescp /var/lib/rabbitmq/.erlang.cookie root@node3:/var/lib/rabbitmq/.erlang.cookie#重启rabbitmq-server -detached#node2与node3加入进node1集群rabbitmqctl stop_app(rabbitmqctl stop 会将Erlang 虚拟机关闭，rabbitmqctl stop_app 只关闭 RabbitMQ 服务)rabbitmqctl resetrabbitmqctl join_cluster rabbit@node1rabbitmqctl start_app(只启动应用服务)#查询集群状态rabbitmqctl cluster_status#重新设置用户创建账号rabbitmqctl add_user admin 123设置用户角色rabbitmqctl set_user_tags admin administrator设置用户权限rabbitmqctl set_permissions -p "/" admin ".*" ".*" ".*"#解除节点rabbitmqctl stop_apprabbitmqctl resetrabbitmqctl start_apprabbitmqctl cluster_statusrabbitmqctl forget_cluster_node rabbit@node2(node1 机器上执行)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-1-镜像队列"><a href="#9-1-镜像队列" class="headerlink" title="9.1 镜像队列"></a>9.1 镜像队列</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">问题<span class="token operator">:</span>mq集群node1创建的队列其他节点无法复用    解决<span class="token operator">:</span>镜像队列队列可复用<span class="token operator">--</span>暂时只看到页面操作和<span class="token class-name">Linux</span>操作，但没在<span class="token class-name">QueueBuilder</span>中找到参数后续会找如何java配置  name<span class="token operator">:</span>策略名称pattern<span class="token operator">:</span>正则表达式<span class="token punctuation">(</span>mirrior开头的交换机或队列才镜像<span class="token punctuation">)</span>  ha<span class="token operator">-</span>mode<span class="token operator">:</span>指明镜像队列的模式，有效值为 all<span class="token operator">/</span>exactly<span class="token operator">/</span>nodes     all：表示在集群中所有的节点上进行镜像        exactly：表示在指定个数的节点上进行镜像，节点的个数由ha<span class="token operator">-</span>params指定        nodes：表示在指定的节点上进行镜像，节点名称通过ha<span class="token operator">-</span>params指定  ha<span class="token operator">-</span>params：ha<span class="token operator">-</span>mode模式需要用到的参数  ha<span class="token operator">-</span>sync<span class="token operator">-</span>mode：进行队列中消息的同步方式，有效值为automatic和manual      <span class="token operator">--</span><span class="token class-name">Linux</span>  所有<span class="token operator">:</span>  rabbitmqctl set_policy <span class="token operator">-</span>p zat ha<span class="token operator">-</span>allqueue <span class="token string">"^"</span> <span class="token string">'{"ha-mode":"all"}'</span>  限制<span class="token operator">:</span>  rabbitmqctl set_policy ha<span class="token operator">-</span>two <span class="token string">"^"</span> <span class="token string">'{"ha-mode":"exactly","ha-params":2,"ha-sync-mode":"automatic"}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>  页面</p></blockquote><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210720165523531.png" alt="image-20210720165523531"></p><h3 id="9-2-Haproxy实现负载均衡"><a href="#9-2-Haproxy实现负载均衡" class="headerlink" title="9.2 Haproxy实现负载均衡"></a>9.2 Haproxy实现负载均衡</h3><pre class="line-numbers language-none"><code class="language-none">HAProxy 提供高可用性、负载均衡及基于TCPHTTP 应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案，包括 Twitter,Reddit,StackOverflow,GitHub 在内的多家知名互联网公司在使用。HAProxy 实现了一种事件驱动、单一进程模型，此模型支持非常大的井发连接数。nginx,lvs,haproxy 之间的区别: http://www.ha97.com/5646.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">--haproxy.cfg配置:vim /etc/haproxy/haproxy.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://www.cnblogs.com/2567xl/p/11640991.html">haproxy.cfg配置详解网址</a></p><p><a href="https://hub.docker.com/_/haproxy">hub.docker启动</a></p><h3 id="9-3-Keepalived实现高可用"><a href="#9-3-Keepalived实现高可用" class="headerlink" title="9.3 Keepalived实现高可用"></a><strong>9.3 Keepalived实现高可用</strong></h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># Keepalived 它能够通过自身健康检查、资源接管功能做高可用(双机热备)，实现故障转移。修改/etc/keepalived/keepalived.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a href="https://www.cnblogs.com/mzsg/p/5623585.html">简略介绍</a></p><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210720194748885.png" alt="image-20210720194748885"></p><h3 id="9-4-Federation模式插件"><a href="#9-4-Federation模式插件" class="headerlink" title="9.4 Federation模式插件"></a><strong>9.4 Federation模式插件</strong></h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">(broker 北京)，(broker 深圳)彼此之间相距甚远，网络延迟是一个不得不面对的问题。Federation 插件就可以很好地解决这个问题#/plugins目录下启动rabbitmq-plugins enable rabbitmq_federationrabbitmq-plugins enable rabbitmq_federation_management2种方式交换机或队列#交换机#先创建好下游节点downstream 交换机#数据由上游联邦交换机-&gt;下游#配置信息由上游配置#队列<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后续太浅了</p><blockquote><p>Shovel 插件</p></blockquote><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">与Federation相似功能 队列(源端-&gt;目的端)rabbitmq-plugins enable rabbitmq_shovelrabbitmq-plugins enable rabbitmq_shovel_management<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>English</title>
      <link href="/2021/04/09/english/"/>
      <url>/2021/04/09/english/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">开源社会大学Open Source Society University Society:英 /səˈsaɪəti/---内容Contents---总结,摘要Summary<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">免费自学计算机科学教育之路！Path to a free self-taught education in Computer Science!---self-taught:英 /ˌself ˈtɔːt/ education: 英 /ˌedʒuˈkeɪʃn/  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">OSSU的课程是计算机科学的完整教育使用在线资料The OSSU curriculum is a complete education in computer science using online materials---curriculum:英 /kəˈrɪkjələm/materials:英 /mə'tɪərɪəlz/  材料<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">这不仅仅是为了职业培训或职业发展It's not merely for career training or professional development---merely:英 /ˈmɪəli/ career:英 /kəˈrɪə(r)/ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swagger-ssm</title>
      <link href="/2021/04/08/swagger-ssm/"/>
      <url>/2021/04/08/swagger-ssm/</url>
      
        <content type="html"><![CDATA[<h1 id="前置说明"><a href="#前置说明" class="headerlink" title="前置说明"></a>前置说明</h1><p>维护了一个4.08版本spring的项目整合swagger2以及shiro于拦截器。需求虽然只是对传参返参注释，但因为都是使用map。</p><blockquote><p>入参</p></blockquote><p>有swagger自带注解解决</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span>notes <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span>httpMethod <span class="token operator">=</span> <span class="token string">"POST"</span><span class="token punctuation">,</span>tags <span class="token operator">=</span> r"<span class="token punctuation">)</span><span class="token annotation punctuation">@ApiImplicitParams</span><span class="token punctuation">(</span><span class="token annotation punctuation">@ApiImplicitParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span>value <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span>paramType<span class="token operator">=</span><span class="token string">"query"</span><span class="token punctuation">,</span>required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span>defaultValue <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>反参</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//因为swagger2没有对map反参进行支持，只有实体类注解，所以需要自己写方法，感觉csdn大佬lsp,已经写好了demo，剩下的只是整合，整合了很多次，加上公司电脑过慢，4.08版本2天整合好了，我的csdn参考地址如下 只对入参map可以成功，无法实现反参注释功能</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- 最重要的4个包及spring对应版本，也是导致jar包冲突很多的包 其他建议使用maven help插件进行排除 --&gt;</span><span class="token comment">&lt;!-- spring版本号 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>spring.version</span><span class="token punctuation">&gt;</span></span>4.3.18.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>spring.version</span><span class="token punctuation">&gt;</span></span>       <span class="token comment">&lt;!-- spring版本号必须升级 不然会出现requestmapping.path()错误 --&gt;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>springfox-swagger-ui<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.8.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>springfox-swagger2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.8.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.fasterxml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>classmate<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.4.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- guava必须于swagger内中版本一致 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.google.guava<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>guava<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>20.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>csdndemo思路:<a href="https://blog.csdn.net/Hpluvalbe/article/details/107102063?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.control">https://blog.csdn.net/Hpluvalbe/article/details/107102063?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.control</a></p><p>4.08版本<a href="https://blog.csdn.net/year5Javaacg/article/details/115324367?spm=1001.2014.3001.5502">https://blog.csdn.net/year5Javaacg/article/details/115324367?spm=1001.2014.3001.5502</a></p><h2 id="mvc拦截器配置"><a href="#mvc拦截器配置" class="headerlink" title="mvc拦截器配置"></a>mvc拦截器配置</h2><blockquote><p>注意事项 升级swagger和spring版本后 有些自定义拦截器爆红失效,只要重新bean 注入即可</p></blockquote><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- 拦截器 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>interceptors</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 后台拦截器 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>interceptor</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>mapping</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/**<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token comment">&lt;!-- 不拦截静态资源 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>exclude-mapping</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/static/**<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>exclude-mapping</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/favicon.ico<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>exclude-mapping</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/${mapping_path}/**<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>exclude-mapping</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/call/interface/**<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>exclude-mapping</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/api/**<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>exclude-mapping</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/m/**<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token comment">&lt;!--swagger--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>exclude-mapping</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>swagger-ui.html<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>exclude-mapping</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/**/swagger-ui.html<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>exclude-mapping</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/**/swagger-resources/**<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>exclude-mapping</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/**/springfox-swagger-ui/**<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>exclude-mapping</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/**/v2/**<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>exclude-mapping</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/swagger/**<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>exclude-mapping</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/definitions/**<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>  <span class="token comment">&lt;!--有些路径或许重复，这个可能是aop被拦截路径--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>exclude-mapping</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/**/api/**<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>exclude-mapping</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/webjars/springfox-swagger-ui/**<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token comment">&lt;!--swagger--&gt;</span>           <span class="token comment">&lt;!--自己写的登陆拦截器--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.tengfan.system.interceptor.ManageLoginInterceptor<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 不需要验证的地址 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>extcludeUrls<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span><span class="token punctuation">&gt;</span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>/login<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>list</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mvc:</span>interceptor</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mvc:</span>interceptors</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="shiro-xml配置"><a href="#shiro-xml配置" class="headerlink" title="shiro.xml配置"></a>shiro.xml配置</h2><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"> <span class="token comment">&lt;!--shiro过滤链xml配置 Java配置自己找工具--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>shiroFilterChainDefinitions<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.lang.String<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>    /res/** = anon/static/** = anon/favicon.ico = anon/**/*.json=anon/gen/**=anon<span class="token comment">&lt;!--swagger相关配置不拦截--&gt;</span>/swagger/**=anon/configuration/**=anon/webjars/springfox-swagger-ui/**=anon/swagger-ui.html=anon/v2/api-docs=anon/swagger-resources/configuration/ui=anon/swagger-resources=anon/swagger-resources/configuration/security=anon/swagger-resources/**=anon/webjars/** =anon/definitions/** =anon <span class="token comment">&lt;!--有些路径或许重复，这个可能是aop被拦截路径--&gt;</span>/**/api/** =anon<span class="token comment">&lt;!--swagger相关配置不拦截--&gt;</span>/login = authc/logout= logout/** = user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>constructor-arg</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="demo整合及配置"><a href="#demo整合及配置" class="headerlink" title="demo整合及配置"></a>demo整合及配置</h2><pre class="line-numbers language-none"><code class="language-none">//注意事项:我在spring-context中配置注入bean 失效，但在mvc-servlet中就可以。也没太深究，有答案可以回复我，感谢直接引入进自己项目,最重要的2个方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210407152000108.png" alt="image-20210407152000108"></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--启动注解式aop--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>aspectj-autoproxy</span>  <span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.xxx.swagger.SwaggerAop<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.xxx.swagger.ApiResponseBodyReader<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>使用注解进行反参map注释</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//注意type,写支持3种，可以自己修改源码</span><span class="token annotation punctuation">@ApiResponseObject</span><span class="token punctuation">(</span>properties <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@ApiResponseProperty</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span>description <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span>type <span class="token operator">=</span> <span class="token string">"string"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment">//成功界面如下</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210407162611174.png" alt="image-20210407162611174"></p><h2 id="Swagger2配置类"><a href="#Swagger2配置类" class="headerlink" title="Swagger2配置类"></a>Swagger2配置类</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//@Configuration //这里需要注意，如果项目架构是SSM，那就不要加这个注解，如果是 spring boot 架构类型的项目，就必须加上这个注解，让 spring 加载该配置。</span><span class="token comment">//@WebAppConfiguration  // 引入了jt测试 就选这个</span><span class="token annotation punctuation">@EnableSwagger2</span><span class="token comment">//重要！</span><span class="token annotation punctuation">@EnableWebMvc</span> <span class="token comment">// spring boot 项目不需要添加此注解，SSM 项目需要加上此注解，否则将会报错。</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>basePackages <span class="token operator">=</span> <span class="token string">"com.xxx"</span><span class="token punctuation">)</span><span class="token comment">//扫描control所在的package请修改为你control所在package</span><span class="token annotation punctuation">@EnableSwaggerBootstrapUI</span>       <span class="token comment">//扫描control所在的package请修改为你control所在package 后续安全验证登陆注解</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MySwagger2</span> <span class="token punctuation">{</span><span class="token comment">//    private final String basePackage = "com.xxx";</span>       <span class="token comment">/**     * 创建API应用     * apiInfo() 增加API相关信息     * 通过select()函数返回一个ApiSelectorBuilder实例,用来控制哪些接口暴露给Swagger来展现，     * 本例采用指定扫描的包路径来定义指定要建立API的目录。     *     * @return     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Docket</span> <span class="token function">createRestApi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//        ParameterBuilder ticketPar = new ParameterBuilder();</span><span class="token comment">//        List&lt;Parameter&gt; pars = new ArrayList&lt;Parameter&gt;();</span><span class="token comment">//        ticketPar.name("Authorization").description("token")</span><span class="token comment">//                .modelRef(new ModelRef("string"))</span><span class="token comment">//                .parameterType("header")</span><span class="token comment">//                .defaultValue("Bearer" + " ")</span><span class="token comment">//                .required(true)</span><span class="token comment">//                .build();</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Docket</span><span class="token punctuation">(</span><span class="token class-name">DocumentationType</span><span class="token punctuation">.</span>SWAGGER_2<span class="token punctuation">)</span>                <span class="token comment">//忽略特定参数</span><span class="token comment">//                .ignoredParameterTypes(Model.class,HttpSession.class, HttpServletRequest.class, HttpServletResponse.class)</span>                <span class="token punctuation">.</span><span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//                .apis(RequestHandlerSelectors.basePackage(basePackage))</span>                <span class="token punctuation">.</span><span class="token function">apis</span><span class="token punctuation">(</span><span class="token class-name">RequestHandlerSelectors</span><span class="token punctuation">.</span><span class="token function">withClassAnnotation</span><span class="token punctuation">(</span><span class="token class-name">Api</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">paths</span><span class="token punctuation">(</span><span class="token class-name">PathSelectors</span><span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">;</span><span class="token comment">//                .globalOperationParameters(pars);</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 创建该API的基本信息（这些基本 信息会展现在文档页面中）     * 访问地址：http://项目实际地址/swagger-ui.html     * ssm访问地址:http://localhost:/swagger/index.html 另外一种做法     * @return     */</span>    <span class="token keyword">private</span> <span class="token class-name">ApiInfo</span> <span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ApiInfoBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">title</span><span class="token punctuation">(</span><span class="token string">"xxx后台接口"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">description</span><span class="token punctuation">(</span><span class="token string">"如需帮助请访问www.baidu.com"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">termsOfServiceUrl</span><span class="token punctuation">(</span><span class="token string">"http://xxx.html"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">version</span><span class="token punctuation">(</span><span class="token string">"1.0"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安全登陆验证ssm版本"><a href="#安全登陆验证ssm版本" class="headerlink" title="安全登陆验证ssm版本"></a>安全登陆验证ssm版本</h2><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">swagger文档进行安全登陆验证及生产环境禁用(需要自己将pom.xml配置转化在读取，没写)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- https://mvnrepository.com/artifact/com.github.xiaoymin/swagger-bootstrap-ui --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.github.xiaoymin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>swagger-bootstrap-ui<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.9.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableSwaggerBootstrapUI</span><span class="token comment">//MySwagger2 注解</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">//查看springboot相关配置及源码，发现有2个过滤器，可以自己Java配置ProductionSecurityFilter   //是否生产环境,如果是生成环境,过滤Swagger的相关资源请求,如果为正式环境登录成功也没有任何资源,ssm需自己写转换SecurityBasicAuthFilter   //密码账号验证<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>SecurityBasicAuthFilter  部分解析</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MySecurityBasicAuthFilter</span> <span class="token keyword">extends</span> <span class="token class-name">BasicFilter</span> <span class="token keyword">implements</span> <span class="token class-name">Filter</span> <span class="token punctuation">{</span>    <span class="token comment">/***     * 是否开启basic验证,默认不开启     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> enableBasicAuth<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> userName<span class="token operator">=</span><span class="token string">"lmlksy"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token operator">=</span><span class="token string">"password"</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">FilterConfig</span> filterConfig<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{</span>        <span class="token class-name">Enumeration</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> enumeration<span class="token operator">=</span>filterConfig<span class="token punctuation">.</span><span class="token function">getInitParameterNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//SpringMVC环境中,由此init方法初始化此Filter,SpringBoot环境中则不同</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>enumeration<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">setEnableBasicAuth</span><span class="token punctuation">(</span><span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>filterConfig<span class="token punctuation">.</span><span class="token function">getInitParameter</span><span class="token punctuation">(</span><span class="token string">"enableBasicAuth"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">setUserName</span><span class="token punctuation">(</span>filterConfig<span class="token punctuation">.</span><span class="token function">getInitParameter</span><span class="token punctuation">(</span><span class="token string">"lmlksy"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">setPassword</span><span class="token punctuation">(</span>filterConfig<span class="token punctuation">.</span><span class="token function">getInitParameter</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="web-xml配置过滤器"><a href="#web-xml配置过滤器" class="headerlink" title="web.xml配置过滤器"></a>web.xml配置过滤器</h3><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">&gt;</span></span>MySecurityBasicAuthFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">&gt;</span></span>com.xxx.MySecurityBasicAuthFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">&gt;</span></span>MySecurityBasicAuthFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">&gt;</span></span>/swagger-ui.html/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">&gt;</span></span>/v2/api-docs/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!-- swagger-bootstrap-ui 地址 mvc和shiro没有放行如果需要更好看的页面可以进行自配置放行 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">&gt;</span></span>/doc.html/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">&gt;</span></span>MyProductionSecurityFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">&gt;</span></span>com.xxx.MyProductionSecurityFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">&gt;</span></span>MyProductionSecurityFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">&gt;</span></span>/swagger-ui.html/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">&gt;</span></span>/v2/api-docs/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">&gt;</span></span>/doc.html/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 最后一步mvc 配置bean --&gt;</span><span class="token comment">&lt;!-- 成功页面如下 --&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20210407170226018.png" alt="image-20210407170226018"></p><h2 id="注意事项在说明"><a href="#注意事项在说明" class="headerlink" title="注意事项在说明"></a>注意事项在说明</h2><pre class="line-numbers language-none"><code class="language-none">虽然已经有大佬写好demo，剩下的只是版本一致，但升级或者降级版本会有很多方法，依赖冲突不见，推荐使用maven help插件解决冲突。以及查看正确项目版本和日志。当发现spring版本升级后，有些xml依赖传递bean会爆红，只需从新写bean就行了<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SSM-Swagger </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>picGo</title>
      <link href="/2021/04/05/picgo/"/>
      <url>/2021/04/05/picgo/</url>
      
        <content type="html"><![CDATA[<p>下载picGO</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">44673f</span>cf0ba8bc006a805a09ef615919https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>gitee<span class="token punctuation">.</span>com<span class="token operator">/</span>lml000<span class="token operator">/</span>tuc<span class="token operator">/</span>raw<span class="token operator">/</span>master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>还要下载gitee插件</p><p>设置:</p><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20200922133627891.png" alt="image-20200922133627891"></p><p>typora设置:</p><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20200922133706303.png" alt="image-20200922133706303"></p><p>gitee码云设置：注意要公开</p><p>原始地址可以在图片里面查看</p><p><img src="https://gitee.com/lml000/tuc/raw/master/images/image-20200922133839097.png" alt="image-20200922133839097"></p>]]></content>
      
      
      <categories>
          
          <category> picGo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> picGo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
